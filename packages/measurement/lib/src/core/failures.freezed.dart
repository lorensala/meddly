// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$MeasurementFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MeasurementFailureCopyWith<$Res> {
  factory $MeasurementFailureCopyWith(
          MeasurementFailure value, $Res Function(MeasurementFailure) then) =
      _$MeasurementFailureCopyWithImpl<$Res, MeasurementFailure>;
}

/// @nodoc
class _$MeasurementFailureCopyWithImpl<$Res, $Val extends MeasurementFailure>
    implements $MeasurementFailureCopyWith<$Res> {
  _$MeasurementFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MeasurementUnknownFailureCopyWith<$Res> {
  factory _$$MeasurementUnknownFailureCopyWith(
          _$MeasurementUnknownFailure value,
          $Res Function(_$MeasurementUnknownFailure) then) =
      __$$MeasurementUnknownFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementUnknownFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MeasurementUnknownFailure>
    implements _$$MeasurementUnknownFailureCopyWith<$Res> {
  __$$MeasurementUnknownFailureCopyWithImpl(_$MeasurementUnknownFailure _value,
      $Res Function(_$MeasurementUnknownFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementUnknownFailure implements MeasurementUnknownFailure {
  const _$MeasurementUnknownFailure();

  @override
  String toString() {
    return 'MeasurementFailure.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementUnknownFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class MeasurementUnknownFailure implements MeasurementFailure {
  const factory MeasurementUnknownFailure() = _$MeasurementUnknownFailure;
}

/// @nodoc
abstract class _$$MeasurementNotFoundFailureCopyWith<$Res> {
  factory _$$MeasurementNotFoundFailureCopyWith(
          _$MeasurementNotFoundFailure value,
          $Res Function(_$MeasurementNotFoundFailure) then) =
      __$$MeasurementNotFoundFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementNotFoundFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MeasurementNotFoundFailure>
    implements _$$MeasurementNotFoundFailureCopyWith<$Res> {
  __$$MeasurementNotFoundFailureCopyWithImpl(
      _$MeasurementNotFoundFailure _value,
      $Res Function(_$MeasurementNotFoundFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementNotFoundFailure implements MeasurementNotFoundFailure {
  const _$MeasurementNotFoundFailure();

  @override
  String toString() {
    return 'MeasurementFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementNotFoundFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class MeasurementNotFoundFailure implements MeasurementFailure {
  const factory MeasurementNotFoundFailure() = _$MeasurementNotFoundFailure;
}

/// @nodoc
abstract class _$$MeasurementSerializationFailureCopyWith<$Res> {
  factory _$$MeasurementSerializationFailureCopyWith(
          _$MeasurementSerializationFailure value,
          $Res Function(_$MeasurementSerializationFailure) then) =
      __$$MeasurementSerializationFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementSerializationFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res,
        _$MeasurementSerializationFailure>
    implements _$$MeasurementSerializationFailureCopyWith<$Res> {
  __$$MeasurementSerializationFailureCopyWithImpl(
      _$MeasurementSerializationFailure _value,
      $Res Function(_$MeasurementSerializationFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementSerializationFailure
    implements MeasurementSerializationFailure {
  const _$MeasurementSerializationFailure();

  @override
  String toString() {
    return 'MeasurementFailure.serialization()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementSerializationFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return serialization();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return serialization?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return serialization(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return serialization?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization(this);
    }
    return orElse();
  }
}

abstract class MeasurementSerializationFailure implements MeasurementFailure {
  const factory MeasurementSerializationFailure() =
      _$MeasurementSerializationFailure;
}

/// @nodoc
abstract class _$$MeasurementSendTimeoutFailureCopyWith<$Res> {
  factory _$$MeasurementSendTimeoutFailureCopyWith(
          _$MeasurementSendTimeoutFailure value,
          $Res Function(_$MeasurementSendTimeoutFailure) then) =
      __$$MeasurementSendTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementSendTimeoutFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res,
        _$MeasurementSendTimeoutFailure>
    implements _$$MeasurementSendTimeoutFailureCopyWith<$Res> {
  __$$MeasurementSendTimeoutFailureCopyWithImpl(
      _$MeasurementSendTimeoutFailure _value,
      $Res Function(_$MeasurementSendTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementSendTimeoutFailure implements MeasurementSendTimeoutFailure {
  const _$MeasurementSendTimeoutFailure();

  @override
  String toString() {
    return 'MeasurementFailure.sendTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementSendTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return sendTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return sendTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return sendTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return sendTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout(this);
    }
    return orElse();
  }
}

abstract class MeasurementSendTimeoutFailure implements MeasurementFailure {
  const factory MeasurementSendTimeoutFailure() =
      _$MeasurementSendTimeoutFailure;
}

/// @nodoc
abstract class _$$MeasurementReceiveTimeoutFailureCopyWith<$Res> {
  factory _$$MeasurementReceiveTimeoutFailureCopyWith(
          _$MeasurementReceiveTimeoutFailure value,
          $Res Function(_$MeasurementReceiveTimeoutFailure) then) =
      __$$MeasurementReceiveTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementReceiveTimeoutFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res,
        _$MeasurementReceiveTimeoutFailure>
    implements _$$MeasurementReceiveTimeoutFailureCopyWith<$Res> {
  __$$MeasurementReceiveTimeoutFailureCopyWithImpl(
      _$MeasurementReceiveTimeoutFailure _value,
      $Res Function(_$MeasurementReceiveTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementReceiveTimeoutFailure
    implements MeasurementReceiveTimeoutFailure {
  const _$MeasurementReceiveTimeoutFailure();

  @override
  String toString() {
    return 'MeasurementFailure.receiveTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementReceiveTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return receiveTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return receiveTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return receiveTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return receiveTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout(this);
    }
    return orElse();
  }
}

abstract class MeasurementReceiveTimeoutFailure implements MeasurementFailure {
  const factory MeasurementReceiveTimeoutFailure() =
      _$MeasurementReceiveTimeoutFailure;
}

/// @nodoc
abstract class _$$MeasurementResponseFailureCopyWith<$Res> {
  factory _$$MeasurementResponseFailureCopyWith(
          _$MeasurementResponseFailure value,
          $Res Function(_$MeasurementResponseFailure) then) =
      __$$MeasurementResponseFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementResponseFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MeasurementResponseFailure>
    implements _$$MeasurementResponseFailureCopyWith<$Res> {
  __$$MeasurementResponseFailureCopyWithImpl(
      _$MeasurementResponseFailure _value,
      $Res Function(_$MeasurementResponseFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementResponseFailure implements MeasurementResponseFailure {
  const _$MeasurementResponseFailure();

  @override
  String toString() {
    return 'MeasurementFailure.response()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementResponseFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return response();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return response?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return response(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return response?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response(this);
    }
    return orElse();
  }
}

abstract class MeasurementResponseFailure implements MeasurementFailure {
  const factory MeasurementResponseFailure() = _$MeasurementResponseFailure;
}

/// @nodoc
abstract class _$$MeasurementCancelFailureCopyWith<$Res> {
  factory _$$MeasurementCancelFailureCopyWith(_$MeasurementCancelFailure value,
          $Res Function(_$MeasurementCancelFailure) then) =
      __$$MeasurementCancelFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementCancelFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MeasurementCancelFailure>
    implements _$$MeasurementCancelFailureCopyWith<$Res> {
  __$$MeasurementCancelFailureCopyWithImpl(_$MeasurementCancelFailure _value,
      $Res Function(_$MeasurementCancelFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementCancelFailure implements MeasurementCancelFailure {
  const _$MeasurementCancelFailure();

  @override
  String toString() {
    return 'MeasurementFailure.cancel()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementCancelFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return cancel();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return cancel?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return cancel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return cancel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel(this);
    }
    return orElse();
  }
}

abstract class MeasurementCancelFailure implements MeasurementFailure {
  const factory MeasurementCancelFailure() = _$MeasurementCancelFailure;
}

/// @nodoc
abstract class _$$MeasurementCacheFailureCopyWith<$Res> {
  factory _$$MeasurementCacheFailureCopyWith(_$MeasurementCacheFailure value,
          $Res Function(_$MeasurementCacheFailure) then) =
      __$$MeasurementCacheFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementCacheFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MeasurementCacheFailure>
    implements _$$MeasurementCacheFailureCopyWith<$Res> {
  __$$MeasurementCacheFailureCopyWithImpl(_$MeasurementCacheFailure _value,
      $Res Function(_$MeasurementCacheFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementCacheFailure implements MeasurementCacheFailure {
  const _$MeasurementCacheFailure();

  @override
  String toString() {
    return 'MeasurementFailure.cache()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementCacheFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return cache();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return cache?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return cache(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return cache?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache(this);
    }
    return orElse();
  }
}

abstract class MeasurementCacheFailure implements MeasurementFailure {
  const factory MeasurementCacheFailure() = _$MeasurementCacheFailure;
}

/// @nodoc
abstract class _$$MeasurementConnectionTimeOutFailureCopyWith<$Res> {
  factory _$$MeasurementConnectionTimeOutFailureCopyWith(
          _$MeasurementConnectionTimeOutFailure value,
          $Res Function(_$MeasurementConnectionTimeOutFailure) then) =
      __$$MeasurementConnectionTimeOutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementConnectionTimeOutFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res,
        _$MeasurementConnectionTimeOutFailure>
    implements _$$MeasurementConnectionTimeOutFailureCopyWith<$Res> {
  __$$MeasurementConnectionTimeOutFailureCopyWithImpl(
      _$MeasurementConnectionTimeOutFailure _value,
      $Res Function(_$MeasurementConnectionTimeOutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementConnectionTimeOutFailure
    implements MeasurementConnectionTimeOutFailure {
  const _$MeasurementConnectionTimeOutFailure();

  @override
  String toString() {
    return 'MeasurementFailure.connectionTimeOut()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementConnectionTimeOutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return connectionTimeOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return connectionTimeOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (connectionTimeOut != null) {
      return connectionTimeOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return connectionTimeOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return connectionTimeOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (connectionTimeOut != null) {
      return connectionTimeOut(this);
    }
    return orElse();
  }
}

abstract class MeasurementConnectionTimeOutFailure
    implements MeasurementFailure {
  const factory MeasurementConnectionTimeOutFailure() =
      _$MeasurementConnectionTimeOutFailure;
}
