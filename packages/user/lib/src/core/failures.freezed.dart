// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$UserFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserNotFoundFailure value) notFound,
    required TResult Function(UserTimeoutFailure value) timeout,
    required TResult Function(UserSerializationFailure value) serialization,
    required TResult Function(UserSendTimeoutFailure value) sendTimeout,
    required TResult Function(UserReceiveTimeoutFailure value) receiveTimeout,
    required TResult Function(UserResponseFailure value) response,
    required TResult Function(UserCancelFailure value) cancel,
    required TResult Function(UserCacheFailure value) cache,
    required TResult Function(UserUnknownFailure value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserNotFoundFailure value)? notFound,
    TResult? Function(UserTimeoutFailure value)? timeout,
    TResult? Function(UserSerializationFailure value)? serialization,
    TResult? Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult? Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(UserResponseFailure value)? response,
    TResult? Function(UserCancelFailure value)? cancel,
    TResult? Function(UserCacheFailure value)? cache,
    TResult? Function(UserUnknownFailure value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserNotFoundFailure value)? notFound,
    TResult Function(UserTimeoutFailure value)? timeout,
    TResult Function(UserSerializationFailure value)? serialization,
    TResult Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(UserResponseFailure value)? response,
    TResult Function(UserCancelFailure value)? cancel,
    TResult Function(UserCacheFailure value)? cache,
    TResult Function(UserUnknownFailure value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserFailureCopyWith<$Res> {
  factory $UserFailureCopyWith(
          UserFailure value, $Res Function(UserFailure) then) =
      _$UserFailureCopyWithImpl<$Res, UserFailure>;
}

/// @nodoc
class _$UserFailureCopyWithImpl<$Res, $Val extends UserFailure>
    implements $UserFailureCopyWith<$Res> {
  _$UserFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserNotFoundFailureCopyWith<$Res> {
  factory _$$UserNotFoundFailureCopyWith(_$UserNotFoundFailure value,
          $Res Function(_$UserNotFoundFailure) then) =
      __$$UserNotFoundFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserNotFoundFailureCopyWithImpl<$Res>
    extends _$UserFailureCopyWithImpl<$Res, _$UserNotFoundFailure>
    implements _$$UserNotFoundFailureCopyWith<$Res> {
  __$$UserNotFoundFailureCopyWithImpl(
      _$UserNotFoundFailure _value, $Res Function(_$UserNotFoundFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserNotFoundFailure implements UserNotFoundFailure {
  const _$UserNotFoundFailure();

  @override
  String toString() {
    return 'UserFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserNotFoundFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserNotFoundFailure value) notFound,
    required TResult Function(UserTimeoutFailure value) timeout,
    required TResult Function(UserSerializationFailure value) serialization,
    required TResult Function(UserSendTimeoutFailure value) sendTimeout,
    required TResult Function(UserReceiveTimeoutFailure value) receiveTimeout,
    required TResult Function(UserResponseFailure value) response,
    required TResult Function(UserCancelFailure value) cancel,
    required TResult Function(UserCacheFailure value) cache,
    required TResult Function(UserUnknownFailure value) unknown,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserNotFoundFailure value)? notFound,
    TResult? Function(UserTimeoutFailure value)? timeout,
    TResult? Function(UserSerializationFailure value)? serialization,
    TResult? Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult? Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(UserResponseFailure value)? response,
    TResult? Function(UserCancelFailure value)? cancel,
    TResult? Function(UserCacheFailure value)? cache,
    TResult? Function(UserUnknownFailure value)? unknown,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserNotFoundFailure value)? notFound,
    TResult Function(UserTimeoutFailure value)? timeout,
    TResult Function(UserSerializationFailure value)? serialization,
    TResult Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(UserResponseFailure value)? response,
    TResult Function(UserCancelFailure value)? cancel,
    TResult Function(UserCacheFailure value)? cache,
    TResult Function(UserUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class UserNotFoundFailure implements UserFailure {
  const factory UserNotFoundFailure() = _$UserNotFoundFailure;
}

/// @nodoc
abstract class _$$UserTimeoutFailureCopyWith<$Res> {
  factory _$$UserTimeoutFailureCopyWith(_$UserTimeoutFailure value,
          $Res Function(_$UserTimeoutFailure) then) =
      __$$UserTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserTimeoutFailureCopyWithImpl<$Res>
    extends _$UserFailureCopyWithImpl<$Res, _$UserTimeoutFailure>
    implements _$$UserTimeoutFailureCopyWith<$Res> {
  __$$UserTimeoutFailureCopyWithImpl(
      _$UserTimeoutFailure _value, $Res Function(_$UserTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserTimeoutFailure implements UserTimeoutFailure {
  const _$UserTimeoutFailure();

  @override
  String toString() {
    return 'UserFailure.timeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return timeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return timeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserNotFoundFailure value) notFound,
    required TResult Function(UserTimeoutFailure value) timeout,
    required TResult Function(UserSerializationFailure value) serialization,
    required TResult Function(UserSendTimeoutFailure value) sendTimeout,
    required TResult Function(UserReceiveTimeoutFailure value) receiveTimeout,
    required TResult Function(UserResponseFailure value) response,
    required TResult Function(UserCancelFailure value) cancel,
    required TResult Function(UserCacheFailure value) cache,
    required TResult Function(UserUnknownFailure value) unknown,
  }) {
    return timeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserNotFoundFailure value)? notFound,
    TResult? Function(UserTimeoutFailure value)? timeout,
    TResult? Function(UserSerializationFailure value)? serialization,
    TResult? Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult? Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(UserResponseFailure value)? response,
    TResult? Function(UserCancelFailure value)? cancel,
    TResult? Function(UserCacheFailure value)? cache,
    TResult? Function(UserUnknownFailure value)? unknown,
  }) {
    return timeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserNotFoundFailure value)? notFound,
    TResult Function(UserTimeoutFailure value)? timeout,
    TResult Function(UserSerializationFailure value)? serialization,
    TResult Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(UserResponseFailure value)? response,
    TResult Function(UserCancelFailure value)? cancel,
    TResult Function(UserCacheFailure value)? cache,
    TResult Function(UserUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout(this);
    }
    return orElse();
  }
}

abstract class UserTimeoutFailure implements UserFailure {
  const factory UserTimeoutFailure() = _$UserTimeoutFailure;
}

/// @nodoc
abstract class _$$UserSerializationFailureCopyWith<$Res> {
  factory _$$UserSerializationFailureCopyWith(_$UserSerializationFailure value,
          $Res Function(_$UserSerializationFailure) then) =
      __$$UserSerializationFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserSerializationFailureCopyWithImpl<$Res>
    extends _$UserFailureCopyWithImpl<$Res, _$UserSerializationFailure>
    implements _$$UserSerializationFailureCopyWith<$Res> {
  __$$UserSerializationFailureCopyWithImpl(_$UserSerializationFailure _value,
      $Res Function(_$UserSerializationFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserSerializationFailure implements UserSerializationFailure {
  const _$UserSerializationFailure();

  @override
  String toString() {
    return 'UserFailure.serialization()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserSerializationFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return serialization();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return serialization?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserNotFoundFailure value) notFound,
    required TResult Function(UserTimeoutFailure value) timeout,
    required TResult Function(UserSerializationFailure value) serialization,
    required TResult Function(UserSendTimeoutFailure value) sendTimeout,
    required TResult Function(UserReceiveTimeoutFailure value) receiveTimeout,
    required TResult Function(UserResponseFailure value) response,
    required TResult Function(UserCancelFailure value) cancel,
    required TResult Function(UserCacheFailure value) cache,
    required TResult Function(UserUnknownFailure value) unknown,
  }) {
    return serialization(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserNotFoundFailure value)? notFound,
    TResult? Function(UserTimeoutFailure value)? timeout,
    TResult? Function(UserSerializationFailure value)? serialization,
    TResult? Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult? Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(UserResponseFailure value)? response,
    TResult? Function(UserCancelFailure value)? cancel,
    TResult? Function(UserCacheFailure value)? cache,
    TResult? Function(UserUnknownFailure value)? unknown,
  }) {
    return serialization?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserNotFoundFailure value)? notFound,
    TResult Function(UserTimeoutFailure value)? timeout,
    TResult Function(UserSerializationFailure value)? serialization,
    TResult Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(UserResponseFailure value)? response,
    TResult Function(UserCancelFailure value)? cancel,
    TResult Function(UserCacheFailure value)? cache,
    TResult Function(UserUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization(this);
    }
    return orElse();
  }
}

abstract class UserSerializationFailure implements UserFailure {
  const factory UserSerializationFailure() = _$UserSerializationFailure;
}

/// @nodoc
abstract class _$$UserSendTimeoutFailureCopyWith<$Res> {
  factory _$$UserSendTimeoutFailureCopyWith(_$UserSendTimeoutFailure value,
          $Res Function(_$UserSendTimeoutFailure) then) =
      __$$UserSendTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserSendTimeoutFailureCopyWithImpl<$Res>
    extends _$UserFailureCopyWithImpl<$Res, _$UserSendTimeoutFailure>
    implements _$$UserSendTimeoutFailureCopyWith<$Res> {
  __$$UserSendTimeoutFailureCopyWithImpl(_$UserSendTimeoutFailure _value,
      $Res Function(_$UserSendTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserSendTimeoutFailure implements UserSendTimeoutFailure {
  const _$UserSendTimeoutFailure();

  @override
  String toString() {
    return 'UserFailure.sendTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserSendTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return sendTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return sendTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserNotFoundFailure value) notFound,
    required TResult Function(UserTimeoutFailure value) timeout,
    required TResult Function(UserSerializationFailure value) serialization,
    required TResult Function(UserSendTimeoutFailure value) sendTimeout,
    required TResult Function(UserReceiveTimeoutFailure value) receiveTimeout,
    required TResult Function(UserResponseFailure value) response,
    required TResult Function(UserCancelFailure value) cancel,
    required TResult Function(UserCacheFailure value) cache,
    required TResult Function(UserUnknownFailure value) unknown,
  }) {
    return sendTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserNotFoundFailure value)? notFound,
    TResult? Function(UserTimeoutFailure value)? timeout,
    TResult? Function(UserSerializationFailure value)? serialization,
    TResult? Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult? Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(UserResponseFailure value)? response,
    TResult? Function(UserCancelFailure value)? cancel,
    TResult? Function(UserCacheFailure value)? cache,
    TResult? Function(UserUnknownFailure value)? unknown,
  }) {
    return sendTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserNotFoundFailure value)? notFound,
    TResult Function(UserTimeoutFailure value)? timeout,
    TResult Function(UserSerializationFailure value)? serialization,
    TResult Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(UserResponseFailure value)? response,
    TResult Function(UserCancelFailure value)? cancel,
    TResult Function(UserCacheFailure value)? cache,
    TResult Function(UserUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout(this);
    }
    return orElse();
  }
}

abstract class UserSendTimeoutFailure implements UserFailure {
  const factory UserSendTimeoutFailure() = _$UserSendTimeoutFailure;
}

/// @nodoc
abstract class _$$UserReceiveTimeoutFailureCopyWith<$Res> {
  factory _$$UserReceiveTimeoutFailureCopyWith(
          _$UserReceiveTimeoutFailure value,
          $Res Function(_$UserReceiveTimeoutFailure) then) =
      __$$UserReceiveTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserReceiveTimeoutFailureCopyWithImpl<$Res>
    extends _$UserFailureCopyWithImpl<$Res, _$UserReceiveTimeoutFailure>
    implements _$$UserReceiveTimeoutFailureCopyWith<$Res> {
  __$$UserReceiveTimeoutFailureCopyWithImpl(_$UserReceiveTimeoutFailure _value,
      $Res Function(_$UserReceiveTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserReceiveTimeoutFailure implements UserReceiveTimeoutFailure {
  const _$UserReceiveTimeoutFailure();

  @override
  String toString() {
    return 'UserFailure.receiveTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserReceiveTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return receiveTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return receiveTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserNotFoundFailure value) notFound,
    required TResult Function(UserTimeoutFailure value) timeout,
    required TResult Function(UserSerializationFailure value) serialization,
    required TResult Function(UserSendTimeoutFailure value) sendTimeout,
    required TResult Function(UserReceiveTimeoutFailure value) receiveTimeout,
    required TResult Function(UserResponseFailure value) response,
    required TResult Function(UserCancelFailure value) cancel,
    required TResult Function(UserCacheFailure value) cache,
    required TResult Function(UserUnknownFailure value) unknown,
  }) {
    return receiveTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserNotFoundFailure value)? notFound,
    TResult? Function(UserTimeoutFailure value)? timeout,
    TResult? Function(UserSerializationFailure value)? serialization,
    TResult? Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult? Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(UserResponseFailure value)? response,
    TResult? Function(UserCancelFailure value)? cancel,
    TResult? Function(UserCacheFailure value)? cache,
    TResult? Function(UserUnknownFailure value)? unknown,
  }) {
    return receiveTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserNotFoundFailure value)? notFound,
    TResult Function(UserTimeoutFailure value)? timeout,
    TResult Function(UserSerializationFailure value)? serialization,
    TResult Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(UserResponseFailure value)? response,
    TResult Function(UserCancelFailure value)? cancel,
    TResult Function(UserCacheFailure value)? cache,
    TResult Function(UserUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout(this);
    }
    return orElse();
  }
}

abstract class UserReceiveTimeoutFailure implements UserFailure {
  const factory UserReceiveTimeoutFailure() = _$UserReceiveTimeoutFailure;
}

/// @nodoc
abstract class _$$UserResponseFailureCopyWith<$Res> {
  factory _$$UserResponseFailureCopyWith(_$UserResponseFailure value,
          $Res Function(_$UserResponseFailure) then) =
      __$$UserResponseFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserResponseFailureCopyWithImpl<$Res>
    extends _$UserFailureCopyWithImpl<$Res, _$UserResponseFailure>
    implements _$$UserResponseFailureCopyWith<$Res> {
  __$$UserResponseFailureCopyWithImpl(
      _$UserResponseFailure _value, $Res Function(_$UserResponseFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserResponseFailure implements UserResponseFailure {
  const _$UserResponseFailure();

  @override
  String toString() {
    return 'UserFailure.response()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserResponseFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return response();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return response?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserNotFoundFailure value) notFound,
    required TResult Function(UserTimeoutFailure value) timeout,
    required TResult Function(UserSerializationFailure value) serialization,
    required TResult Function(UserSendTimeoutFailure value) sendTimeout,
    required TResult Function(UserReceiveTimeoutFailure value) receiveTimeout,
    required TResult Function(UserResponseFailure value) response,
    required TResult Function(UserCancelFailure value) cancel,
    required TResult Function(UserCacheFailure value) cache,
    required TResult Function(UserUnknownFailure value) unknown,
  }) {
    return response(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserNotFoundFailure value)? notFound,
    TResult? Function(UserTimeoutFailure value)? timeout,
    TResult? Function(UserSerializationFailure value)? serialization,
    TResult? Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult? Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(UserResponseFailure value)? response,
    TResult? Function(UserCancelFailure value)? cancel,
    TResult? Function(UserCacheFailure value)? cache,
    TResult? Function(UserUnknownFailure value)? unknown,
  }) {
    return response?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserNotFoundFailure value)? notFound,
    TResult Function(UserTimeoutFailure value)? timeout,
    TResult Function(UserSerializationFailure value)? serialization,
    TResult Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(UserResponseFailure value)? response,
    TResult Function(UserCancelFailure value)? cancel,
    TResult Function(UserCacheFailure value)? cache,
    TResult Function(UserUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response(this);
    }
    return orElse();
  }
}

abstract class UserResponseFailure implements UserFailure {
  const factory UserResponseFailure() = _$UserResponseFailure;
}

/// @nodoc
abstract class _$$UserCancelFailureCopyWith<$Res> {
  factory _$$UserCancelFailureCopyWith(
          _$UserCancelFailure value, $Res Function(_$UserCancelFailure) then) =
      __$$UserCancelFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserCancelFailureCopyWithImpl<$Res>
    extends _$UserFailureCopyWithImpl<$Res, _$UserCancelFailure>
    implements _$$UserCancelFailureCopyWith<$Res> {
  __$$UserCancelFailureCopyWithImpl(
      _$UserCancelFailure _value, $Res Function(_$UserCancelFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserCancelFailure implements UserCancelFailure {
  const _$UserCancelFailure();

  @override
  String toString() {
    return 'UserFailure.cancel()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserCancelFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return cancel();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return cancel?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserNotFoundFailure value) notFound,
    required TResult Function(UserTimeoutFailure value) timeout,
    required TResult Function(UserSerializationFailure value) serialization,
    required TResult Function(UserSendTimeoutFailure value) sendTimeout,
    required TResult Function(UserReceiveTimeoutFailure value) receiveTimeout,
    required TResult Function(UserResponseFailure value) response,
    required TResult Function(UserCancelFailure value) cancel,
    required TResult Function(UserCacheFailure value) cache,
    required TResult Function(UserUnknownFailure value) unknown,
  }) {
    return cancel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserNotFoundFailure value)? notFound,
    TResult? Function(UserTimeoutFailure value)? timeout,
    TResult? Function(UserSerializationFailure value)? serialization,
    TResult? Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult? Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(UserResponseFailure value)? response,
    TResult? Function(UserCancelFailure value)? cancel,
    TResult? Function(UserCacheFailure value)? cache,
    TResult? Function(UserUnknownFailure value)? unknown,
  }) {
    return cancel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserNotFoundFailure value)? notFound,
    TResult Function(UserTimeoutFailure value)? timeout,
    TResult Function(UserSerializationFailure value)? serialization,
    TResult Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(UserResponseFailure value)? response,
    TResult Function(UserCancelFailure value)? cancel,
    TResult Function(UserCacheFailure value)? cache,
    TResult Function(UserUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel(this);
    }
    return orElse();
  }
}

abstract class UserCancelFailure implements UserFailure {
  const factory UserCancelFailure() = _$UserCancelFailure;
}

/// @nodoc
abstract class _$$UserCacheFailureCopyWith<$Res> {
  factory _$$UserCacheFailureCopyWith(
          _$UserCacheFailure value, $Res Function(_$UserCacheFailure) then) =
      __$$UserCacheFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserCacheFailureCopyWithImpl<$Res>
    extends _$UserFailureCopyWithImpl<$Res, _$UserCacheFailure>
    implements _$$UserCacheFailureCopyWith<$Res> {
  __$$UserCacheFailureCopyWithImpl(
      _$UserCacheFailure _value, $Res Function(_$UserCacheFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserCacheFailure implements UserCacheFailure {
  const _$UserCacheFailure();

  @override
  String toString() {
    return 'UserFailure.cache()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserCacheFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return cache();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return cache?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserNotFoundFailure value) notFound,
    required TResult Function(UserTimeoutFailure value) timeout,
    required TResult Function(UserSerializationFailure value) serialization,
    required TResult Function(UserSendTimeoutFailure value) sendTimeout,
    required TResult Function(UserReceiveTimeoutFailure value) receiveTimeout,
    required TResult Function(UserResponseFailure value) response,
    required TResult Function(UserCancelFailure value) cancel,
    required TResult Function(UserCacheFailure value) cache,
    required TResult Function(UserUnknownFailure value) unknown,
  }) {
    return cache(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserNotFoundFailure value)? notFound,
    TResult? Function(UserTimeoutFailure value)? timeout,
    TResult? Function(UserSerializationFailure value)? serialization,
    TResult? Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult? Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(UserResponseFailure value)? response,
    TResult? Function(UserCancelFailure value)? cancel,
    TResult? Function(UserCacheFailure value)? cache,
    TResult? Function(UserUnknownFailure value)? unknown,
  }) {
    return cache?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserNotFoundFailure value)? notFound,
    TResult Function(UserTimeoutFailure value)? timeout,
    TResult Function(UserSerializationFailure value)? serialization,
    TResult Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(UserResponseFailure value)? response,
    TResult Function(UserCancelFailure value)? cancel,
    TResult Function(UserCacheFailure value)? cache,
    TResult Function(UserUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache(this);
    }
    return orElse();
  }
}

abstract class UserCacheFailure implements UserFailure {
  const factory UserCacheFailure() = _$UserCacheFailure;
}

/// @nodoc
abstract class _$$UserUnknownFailureCopyWith<$Res> {
  factory _$$UserUnknownFailureCopyWith(_$UserUnknownFailure value,
          $Res Function(_$UserUnknownFailure) then) =
      __$$UserUnknownFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserUnknownFailureCopyWithImpl<$Res>
    extends _$UserFailureCopyWithImpl<$Res, _$UserUnknownFailure>
    implements _$$UserUnknownFailureCopyWith<$Res> {
  __$$UserUnknownFailureCopyWithImpl(
      _$UserUnknownFailure _value, $Res Function(_$UserUnknownFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserUnknownFailure implements UserUnknownFailure {
  const _$UserUnknownFailure();

  @override
  String toString() {
    return 'UserFailure.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserUnknownFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserNotFoundFailure value) notFound,
    required TResult Function(UserTimeoutFailure value) timeout,
    required TResult Function(UserSerializationFailure value) serialization,
    required TResult Function(UserSendTimeoutFailure value) sendTimeout,
    required TResult Function(UserReceiveTimeoutFailure value) receiveTimeout,
    required TResult Function(UserResponseFailure value) response,
    required TResult Function(UserCancelFailure value) cancel,
    required TResult Function(UserCacheFailure value) cache,
    required TResult Function(UserUnknownFailure value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserNotFoundFailure value)? notFound,
    TResult? Function(UserTimeoutFailure value)? timeout,
    TResult? Function(UserSerializationFailure value)? serialization,
    TResult? Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult? Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(UserResponseFailure value)? response,
    TResult? Function(UserCancelFailure value)? cancel,
    TResult? Function(UserCacheFailure value)? cache,
    TResult? Function(UserUnknownFailure value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserNotFoundFailure value)? notFound,
    TResult Function(UserTimeoutFailure value)? timeout,
    TResult Function(UserSerializationFailure value)? serialization,
    TResult Function(UserSendTimeoutFailure value)? sendTimeout,
    TResult Function(UserReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(UserResponseFailure value)? response,
    TResult Function(UserCancelFailure value)? cancel,
    TResult Function(UserCacheFailure value)? cache,
    TResult Function(UserUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class UserUnknownFailure implements UserFailure {
  const factory UserUnknownFailure() = _$UserUnknownFailure;
}
