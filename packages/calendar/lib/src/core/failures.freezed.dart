// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CalendarFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalendarNotFoundFailure value) notFound,
    required TResult Function(CalendarTimeoutFailure value) timeout,
    required TResult Function(CalendarSerializationFailure value) serialization,
    required TResult Function(CalendarSendTimeoutFailure value) sendTimeout,
    required TResult Function(CalendarReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(CalendarResponseFailure value) response,
    required TResult Function(CalendarCancelFailure value) cancel,
    required TResult Function(CalendarCacheFailure value) cache,
    required TResult Function(CalendarUnknownFailure value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalendarNotFoundFailure value)? notFound,
    TResult? Function(CalendarTimeoutFailure value)? timeout,
    TResult? Function(CalendarSerializationFailure value)? serialization,
    TResult? Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult? Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(CalendarResponseFailure value)? response,
    TResult? Function(CalendarCancelFailure value)? cancel,
    TResult? Function(CalendarCacheFailure value)? cache,
    TResult? Function(CalendarUnknownFailure value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalendarNotFoundFailure value)? notFound,
    TResult Function(CalendarTimeoutFailure value)? timeout,
    TResult Function(CalendarSerializationFailure value)? serialization,
    TResult Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(CalendarResponseFailure value)? response,
    TResult Function(CalendarCancelFailure value)? cancel,
    TResult Function(CalendarCacheFailure value)? cache,
    TResult Function(CalendarUnknownFailure value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalendarFailureCopyWith<$Res> {
  factory $CalendarFailureCopyWith(
          CalendarFailure value, $Res Function(CalendarFailure) then) =
      _$CalendarFailureCopyWithImpl<$Res, CalendarFailure>;
}

/// @nodoc
class _$CalendarFailureCopyWithImpl<$Res, $Val extends CalendarFailure>
    implements $CalendarFailureCopyWith<$Res> {
  _$CalendarFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CalendarNotFoundFailureCopyWith<$Res> {
  factory _$$CalendarNotFoundFailureCopyWith(_$CalendarNotFoundFailure value,
          $Res Function(_$CalendarNotFoundFailure) then) =
      __$$CalendarNotFoundFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalendarNotFoundFailureCopyWithImpl<$Res>
    extends _$CalendarFailureCopyWithImpl<$Res, _$CalendarNotFoundFailure>
    implements _$$CalendarNotFoundFailureCopyWith<$Res> {
  __$$CalendarNotFoundFailureCopyWithImpl(_$CalendarNotFoundFailure _value,
      $Res Function(_$CalendarNotFoundFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CalendarNotFoundFailure implements CalendarNotFoundFailure {
  const _$CalendarNotFoundFailure();

  @override
  String toString() {
    return 'CalendarFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalendarNotFoundFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalendarNotFoundFailure value) notFound,
    required TResult Function(CalendarTimeoutFailure value) timeout,
    required TResult Function(CalendarSerializationFailure value) serialization,
    required TResult Function(CalendarSendTimeoutFailure value) sendTimeout,
    required TResult Function(CalendarReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(CalendarResponseFailure value) response,
    required TResult Function(CalendarCancelFailure value) cancel,
    required TResult Function(CalendarCacheFailure value) cache,
    required TResult Function(CalendarUnknownFailure value) unknown,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalendarNotFoundFailure value)? notFound,
    TResult? Function(CalendarTimeoutFailure value)? timeout,
    TResult? Function(CalendarSerializationFailure value)? serialization,
    TResult? Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult? Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(CalendarResponseFailure value)? response,
    TResult? Function(CalendarCancelFailure value)? cancel,
    TResult? Function(CalendarCacheFailure value)? cache,
    TResult? Function(CalendarUnknownFailure value)? unknown,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalendarNotFoundFailure value)? notFound,
    TResult Function(CalendarTimeoutFailure value)? timeout,
    TResult Function(CalendarSerializationFailure value)? serialization,
    TResult Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(CalendarResponseFailure value)? response,
    TResult Function(CalendarCancelFailure value)? cancel,
    TResult Function(CalendarCacheFailure value)? cache,
    TResult Function(CalendarUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class CalendarNotFoundFailure implements CalendarFailure {
  const factory CalendarNotFoundFailure() = _$CalendarNotFoundFailure;
}

/// @nodoc
abstract class _$$CalendarTimeoutFailureCopyWith<$Res> {
  factory _$$CalendarTimeoutFailureCopyWith(_$CalendarTimeoutFailure value,
          $Res Function(_$CalendarTimeoutFailure) then) =
      __$$CalendarTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalendarTimeoutFailureCopyWithImpl<$Res>
    extends _$CalendarFailureCopyWithImpl<$Res, _$CalendarTimeoutFailure>
    implements _$$CalendarTimeoutFailureCopyWith<$Res> {
  __$$CalendarTimeoutFailureCopyWithImpl(_$CalendarTimeoutFailure _value,
      $Res Function(_$CalendarTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CalendarTimeoutFailure implements CalendarTimeoutFailure {
  const _$CalendarTimeoutFailure();

  @override
  String toString() {
    return 'CalendarFailure.timeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CalendarTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return timeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return timeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalendarNotFoundFailure value) notFound,
    required TResult Function(CalendarTimeoutFailure value) timeout,
    required TResult Function(CalendarSerializationFailure value) serialization,
    required TResult Function(CalendarSendTimeoutFailure value) sendTimeout,
    required TResult Function(CalendarReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(CalendarResponseFailure value) response,
    required TResult Function(CalendarCancelFailure value) cancel,
    required TResult Function(CalendarCacheFailure value) cache,
    required TResult Function(CalendarUnknownFailure value) unknown,
  }) {
    return timeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalendarNotFoundFailure value)? notFound,
    TResult? Function(CalendarTimeoutFailure value)? timeout,
    TResult? Function(CalendarSerializationFailure value)? serialization,
    TResult? Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult? Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(CalendarResponseFailure value)? response,
    TResult? Function(CalendarCancelFailure value)? cancel,
    TResult? Function(CalendarCacheFailure value)? cache,
    TResult? Function(CalendarUnknownFailure value)? unknown,
  }) {
    return timeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalendarNotFoundFailure value)? notFound,
    TResult Function(CalendarTimeoutFailure value)? timeout,
    TResult Function(CalendarSerializationFailure value)? serialization,
    TResult Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(CalendarResponseFailure value)? response,
    TResult Function(CalendarCancelFailure value)? cancel,
    TResult Function(CalendarCacheFailure value)? cache,
    TResult Function(CalendarUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout(this);
    }
    return orElse();
  }
}

abstract class CalendarTimeoutFailure implements CalendarFailure {
  const factory CalendarTimeoutFailure() = _$CalendarTimeoutFailure;
}

/// @nodoc
abstract class _$$CalendarSerializationFailureCopyWith<$Res> {
  factory _$$CalendarSerializationFailureCopyWith(
          _$CalendarSerializationFailure value,
          $Res Function(_$CalendarSerializationFailure) then) =
      __$$CalendarSerializationFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalendarSerializationFailureCopyWithImpl<$Res>
    extends _$CalendarFailureCopyWithImpl<$Res, _$CalendarSerializationFailure>
    implements _$$CalendarSerializationFailureCopyWith<$Res> {
  __$$CalendarSerializationFailureCopyWithImpl(
      _$CalendarSerializationFailure _value,
      $Res Function(_$CalendarSerializationFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CalendarSerializationFailure implements CalendarSerializationFailure {
  const _$CalendarSerializationFailure();

  @override
  String toString() {
    return 'CalendarFailure.serialization()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalendarSerializationFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return serialization();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return serialization?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalendarNotFoundFailure value) notFound,
    required TResult Function(CalendarTimeoutFailure value) timeout,
    required TResult Function(CalendarSerializationFailure value) serialization,
    required TResult Function(CalendarSendTimeoutFailure value) sendTimeout,
    required TResult Function(CalendarReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(CalendarResponseFailure value) response,
    required TResult Function(CalendarCancelFailure value) cancel,
    required TResult Function(CalendarCacheFailure value) cache,
    required TResult Function(CalendarUnknownFailure value) unknown,
  }) {
    return serialization(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalendarNotFoundFailure value)? notFound,
    TResult? Function(CalendarTimeoutFailure value)? timeout,
    TResult? Function(CalendarSerializationFailure value)? serialization,
    TResult? Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult? Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(CalendarResponseFailure value)? response,
    TResult? Function(CalendarCancelFailure value)? cancel,
    TResult? Function(CalendarCacheFailure value)? cache,
    TResult? Function(CalendarUnknownFailure value)? unknown,
  }) {
    return serialization?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalendarNotFoundFailure value)? notFound,
    TResult Function(CalendarTimeoutFailure value)? timeout,
    TResult Function(CalendarSerializationFailure value)? serialization,
    TResult Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(CalendarResponseFailure value)? response,
    TResult Function(CalendarCancelFailure value)? cancel,
    TResult Function(CalendarCacheFailure value)? cache,
    TResult Function(CalendarUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization(this);
    }
    return orElse();
  }
}

abstract class CalendarSerializationFailure implements CalendarFailure {
  const factory CalendarSerializationFailure() = _$CalendarSerializationFailure;
}

/// @nodoc
abstract class _$$CalendarSendTimeoutFailureCopyWith<$Res> {
  factory _$$CalendarSendTimeoutFailureCopyWith(
          _$CalendarSendTimeoutFailure value,
          $Res Function(_$CalendarSendTimeoutFailure) then) =
      __$$CalendarSendTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalendarSendTimeoutFailureCopyWithImpl<$Res>
    extends _$CalendarFailureCopyWithImpl<$Res, _$CalendarSendTimeoutFailure>
    implements _$$CalendarSendTimeoutFailureCopyWith<$Res> {
  __$$CalendarSendTimeoutFailureCopyWithImpl(
      _$CalendarSendTimeoutFailure _value,
      $Res Function(_$CalendarSendTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CalendarSendTimeoutFailure implements CalendarSendTimeoutFailure {
  const _$CalendarSendTimeoutFailure();

  @override
  String toString() {
    return 'CalendarFailure.sendTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalendarSendTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return sendTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return sendTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalendarNotFoundFailure value) notFound,
    required TResult Function(CalendarTimeoutFailure value) timeout,
    required TResult Function(CalendarSerializationFailure value) serialization,
    required TResult Function(CalendarSendTimeoutFailure value) sendTimeout,
    required TResult Function(CalendarReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(CalendarResponseFailure value) response,
    required TResult Function(CalendarCancelFailure value) cancel,
    required TResult Function(CalendarCacheFailure value) cache,
    required TResult Function(CalendarUnknownFailure value) unknown,
  }) {
    return sendTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalendarNotFoundFailure value)? notFound,
    TResult? Function(CalendarTimeoutFailure value)? timeout,
    TResult? Function(CalendarSerializationFailure value)? serialization,
    TResult? Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult? Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(CalendarResponseFailure value)? response,
    TResult? Function(CalendarCancelFailure value)? cancel,
    TResult? Function(CalendarCacheFailure value)? cache,
    TResult? Function(CalendarUnknownFailure value)? unknown,
  }) {
    return sendTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalendarNotFoundFailure value)? notFound,
    TResult Function(CalendarTimeoutFailure value)? timeout,
    TResult Function(CalendarSerializationFailure value)? serialization,
    TResult Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(CalendarResponseFailure value)? response,
    TResult Function(CalendarCancelFailure value)? cancel,
    TResult Function(CalendarCacheFailure value)? cache,
    TResult Function(CalendarUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout(this);
    }
    return orElse();
  }
}

abstract class CalendarSendTimeoutFailure implements CalendarFailure {
  const factory CalendarSendTimeoutFailure() = _$CalendarSendTimeoutFailure;
}

/// @nodoc
abstract class _$$CalendarReceiveTimeoutFailureCopyWith<$Res> {
  factory _$$CalendarReceiveTimeoutFailureCopyWith(
          _$CalendarReceiveTimeoutFailure value,
          $Res Function(_$CalendarReceiveTimeoutFailure) then) =
      __$$CalendarReceiveTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalendarReceiveTimeoutFailureCopyWithImpl<$Res>
    extends _$CalendarFailureCopyWithImpl<$Res, _$CalendarReceiveTimeoutFailure>
    implements _$$CalendarReceiveTimeoutFailureCopyWith<$Res> {
  __$$CalendarReceiveTimeoutFailureCopyWithImpl(
      _$CalendarReceiveTimeoutFailure _value,
      $Res Function(_$CalendarReceiveTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CalendarReceiveTimeoutFailure implements CalendarReceiveTimeoutFailure {
  const _$CalendarReceiveTimeoutFailure();

  @override
  String toString() {
    return 'CalendarFailure.receiveTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalendarReceiveTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return receiveTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return receiveTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalendarNotFoundFailure value) notFound,
    required TResult Function(CalendarTimeoutFailure value) timeout,
    required TResult Function(CalendarSerializationFailure value) serialization,
    required TResult Function(CalendarSendTimeoutFailure value) sendTimeout,
    required TResult Function(CalendarReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(CalendarResponseFailure value) response,
    required TResult Function(CalendarCancelFailure value) cancel,
    required TResult Function(CalendarCacheFailure value) cache,
    required TResult Function(CalendarUnknownFailure value) unknown,
  }) {
    return receiveTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalendarNotFoundFailure value)? notFound,
    TResult? Function(CalendarTimeoutFailure value)? timeout,
    TResult? Function(CalendarSerializationFailure value)? serialization,
    TResult? Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult? Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(CalendarResponseFailure value)? response,
    TResult? Function(CalendarCancelFailure value)? cancel,
    TResult? Function(CalendarCacheFailure value)? cache,
    TResult? Function(CalendarUnknownFailure value)? unknown,
  }) {
    return receiveTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalendarNotFoundFailure value)? notFound,
    TResult Function(CalendarTimeoutFailure value)? timeout,
    TResult Function(CalendarSerializationFailure value)? serialization,
    TResult Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(CalendarResponseFailure value)? response,
    TResult Function(CalendarCancelFailure value)? cancel,
    TResult Function(CalendarCacheFailure value)? cache,
    TResult Function(CalendarUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout(this);
    }
    return orElse();
  }
}

abstract class CalendarReceiveTimeoutFailure implements CalendarFailure {
  const factory CalendarReceiveTimeoutFailure() =
      _$CalendarReceiveTimeoutFailure;
}

/// @nodoc
abstract class _$$CalendarResponseFailureCopyWith<$Res> {
  factory _$$CalendarResponseFailureCopyWith(_$CalendarResponseFailure value,
          $Res Function(_$CalendarResponseFailure) then) =
      __$$CalendarResponseFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalendarResponseFailureCopyWithImpl<$Res>
    extends _$CalendarFailureCopyWithImpl<$Res, _$CalendarResponseFailure>
    implements _$$CalendarResponseFailureCopyWith<$Res> {
  __$$CalendarResponseFailureCopyWithImpl(_$CalendarResponseFailure _value,
      $Res Function(_$CalendarResponseFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CalendarResponseFailure implements CalendarResponseFailure {
  const _$CalendarResponseFailure();

  @override
  String toString() {
    return 'CalendarFailure.response()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalendarResponseFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return response();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return response?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalendarNotFoundFailure value) notFound,
    required TResult Function(CalendarTimeoutFailure value) timeout,
    required TResult Function(CalendarSerializationFailure value) serialization,
    required TResult Function(CalendarSendTimeoutFailure value) sendTimeout,
    required TResult Function(CalendarReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(CalendarResponseFailure value) response,
    required TResult Function(CalendarCancelFailure value) cancel,
    required TResult Function(CalendarCacheFailure value) cache,
    required TResult Function(CalendarUnknownFailure value) unknown,
  }) {
    return response(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalendarNotFoundFailure value)? notFound,
    TResult? Function(CalendarTimeoutFailure value)? timeout,
    TResult? Function(CalendarSerializationFailure value)? serialization,
    TResult? Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult? Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(CalendarResponseFailure value)? response,
    TResult? Function(CalendarCancelFailure value)? cancel,
    TResult? Function(CalendarCacheFailure value)? cache,
    TResult? Function(CalendarUnknownFailure value)? unknown,
  }) {
    return response?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalendarNotFoundFailure value)? notFound,
    TResult Function(CalendarTimeoutFailure value)? timeout,
    TResult Function(CalendarSerializationFailure value)? serialization,
    TResult Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(CalendarResponseFailure value)? response,
    TResult Function(CalendarCancelFailure value)? cancel,
    TResult Function(CalendarCacheFailure value)? cache,
    TResult Function(CalendarUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response(this);
    }
    return orElse();
  }
}

abstract class CalendarResponseFailure implements CalendarFailure {
  const factory CalendarResponseFailure() = _$CalendarResponseFailure;
}

/// @nodoc
abstract class _$$CalendarCancelFailureCopyWith<$Res> {
  factory _$$CalendarCancelFailureCopyWith(_$CalendarCancelFailure value,
          $Res Function(_$CalendarCancelFailure) then) =
      __$$CalendarCancelFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalendarCancelFailureCopyWithImpl<$Res>
    extends _$CalendarFailureCopyWithImpl<$Res, _$CalendarCancelFailure>
    implements _$$CalendarCancelFailureCopyWith<$Res> {
  __$$CalendarCancelFailureCopyWithImpl(_$CalendarCancelFailure _value,
      $Res Function(_$CalendarCancelFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CalendarCancelFailure implements CalendarCancelFailure {
  const _$CalendarCancelFailure();

  @override
  String toString() {
    return 'CalendarFailure.cancel()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CalendarCancelFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return cancel();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return cancel?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalendarNotFoundFailure value) notFound,
    required TResult Function(CalendarTimeoutFailure value) timeout,
    required TResult Function(CalendarSerializationFailure value) serialization,
    required TResult Function(CalendarSendTimeoutFailure value) sendTimeout,
    required TResult Function(CalendarReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(CalendarResponseFailure value) response,
    required TResult Function(CalendarCancelFailure value) cancel,
    required TResult Function(CalendarCacheFailure value) cache,
    required TResult Function(CalendarUnknownFailure value) unknown,
  }) {
    return cancel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalendarNotFoundFailure value)? notFound,
    TResult? Function(CalendarTimeoutFailure value)? timeout,
    TResult? Function(CalendarSerializationFailure value)? serialization,
    TResult? Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult? Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(CalendarResponseFailure value)? response,
    TResult? Function(CalendarCancelFailure value)? cancel,
    TResult? Function(CalendarCacheFailure value)? cache,
    TResult? Function(CalendarUnknownFailure value)? unknown,
  }) {
    return cancel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalendarNotFoundFailure value)? notFound,
    TResult Function(CalendarTimeoutFailure value)? timeout,
    TResult Function(CalendarSerializationFailure value)? serialization,
    TResult Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(CalendarResponseFailure value)? response,
    TResult Function(CalendarCancelFailure value)? cancel,
    TResult Function(CalendarCacheFailure value)? cache,
    TResult Function(CalendarUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel(this);
    }
    return orElse();
  }
}

abstract class CalendarCancelFailure implements CalendarFailure {
  const factory CalendarCancelFailure() = _$CalendarCancelFailure;
}

/// @nodoc
abstract class _$$CalendarCacheFailureCopyWith<$Res> {
  factory _$$CalendarCacheFailureCopyWith(_$CalendarCacheFailure value,
          $Res Function(_$CalendarCacheFailure) then) =
      __$$CalendarCacheFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalendarCacheFailureCopyWithImpl<$Res>
    extends _$CalendarFailureCopyWithImpl<$Res, _$CalendarCacheFailure>
    implements _$$CalendarCacheFailureCopyWith<$Res> {
  __$$CalendarCacheFailureCopyWithImpl(_$CalendarCacheFailure _value,
      $Res Function(_$CalendarCacheFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CalendarCacheFailure implements CalendarCacheFailure {
  const _$CalendarCacheFailure();

  @override
  String toString() {
    return 'CalendarFailure.cache()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CalendarCacheFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return cache();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return cache?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalendarNotFoundFailure value) notFound,
    required TResult Function(CalendarTimeoutFailure value) timeout,
    required TResult Function(CalendarSerializationFailure value) serialization,
    required TResult Function(CalendarSendTimeoutFailure value) sendTimeout,
    required TResult Function(CalendarReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(CalendarResponseFailure value) response,
    required TResult Function(CalendarCancelFailure value) cancel,
    required TResult Function(CalendarCacheFailure value) cache,
    required TResult Function(CalendarUnknownFailure value) unknown,
  }) {
    return cache(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalendarNotFoundFailure value)? notFound,
    TResult? Function(CalendarTimeoutFailure value)? timeout,
    TResult? Function(CalendarSerializationFailure value)? serialization,
    TResult? Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult? Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(CalendarResponseFailure value)? response,
    TResult? Function(CalendarCancelFailure value)? cancel,
    TResult? Function(CalendarCacheFailure value)? cache,
    TResult? Function(CalendarUnknownFailure value)? unknown,
  }) {
    return cache?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalendarNotFoundFailure value)? notFound,
    TResult Function(CalendarTimeoutFailure value)? timeout,
    TResult Function(CalendarSerializationFailure value)? serialization,
    TResult Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(CalendarResponseFailure value)? response,
    TResult Function(CalendarCancelFailure value)? cancel,
    TResult Function(CalendarCacheFailure value)? cache,
    TResult Function(CalendarUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache(this);
    }
    return orElse();
  }
}

abstract class CalendarCacheFailure implements CalendarFailure {
  const factory CalendarCacheFailure() = _$CalendarCacheFailure;
}

/// @nodoc
abstract class _$$CalendarUnknownFailureCopyWith<$Res> {
  factory _$$CalendarUnknownFailureCopyWith(_$CalendarUnknownFailure value,
          $Res Function(_$CalendarUnknownFailure) then) =
      __$$CalendarUnknownFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalendarUnknownFailureCopyWithImpl<$Res>
    extends _$CalendarFailureCopyWithImpl<$Res, _$CalendarUnknownFailure>
    implements _$$CalendarUnknownFailureCopyWith<$Res> {
  __$$CalendarUnknownFailureCopyWithImpl(_$CalendarUnknownFailure _value,
      $Res Function(_$CalendarUnknownFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CalendarUnknownFailure implements CalendarUnknownFailure {
  const _$CalendarUnknownFailure();

  @override
  String toString() {
    return 'CalendarFailure.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CalendarUnknownFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalendarNotFoundFailure value) notFound,
    required TResult Function(CalendarTimeoutFailure value) timeout,
    required TResult Function(CalendarSerializationFailure value) serialization,
    required TResult Function(CalendarSendTimeoutFailure value) sendTimeout,
    required TResult Function(CalendarReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(CalendarResponseFailure value) response,
    required TResult Function(CalendarCancelFailure value) cancel,
    required TResult Function(CalendarCacheFailure value) cache,
    required TResult Function(CalendarUnknownFailure value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalendarNotFoundFailure value)? notFound,
    TResult? Function(CalendarTimeoutFailure value)? timeout,
    TResult? Function(CalendarSerializationFailure value)? serialization,
    TResult? Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult? Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(CalendarResponseFailure value)? response,
    TResult? Function(CalendarCancelFailure value)? cancel,
    TResult? Function(CalendarCacheFailure value)? cache,
    TResult? Function(CalendarUnknownFailure value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalendarNotFoundFailure value)? notFound,
    TResult Function(CalendarTimeoutFailure value)? timeout,
    TResult Function(CalendarSerializationFailure value)? serialization,
    TResult Function(CalendarSendTimeoutFailure value)? sendTimeout,
    TResult Function(CalendarReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(CalendarResponseFailure value)? response,
    TResult Function(CalendarCancelFailure value)? cancel,
    TResult Function(CalendarCacheFailure value)? cache,
    TResult Function(CalendarUnknownFailure value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class CalendarUnknownFailure implements CalendarFailure {
  const factory CalendarUnknownFailure() = _$CalendarUnknownFailure;
}

/// @nodoc
mixin _$MedicineFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MedicineUnknownFailure value) unknown,
    required TResult Function(MedicineNotFoundFailure value) notFound,
    required TResult Function(MedicineSerializationFailure value) serialization,
    required TResult Function(MedicineSendTimeoutFailure value) sendTimeout,
    required TResult Function(MedicineReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MedicineResponseFailure value) response,
    required TResult Function(MedicineCancelFailure value) cancel,
    required TResult Function(MedicineCacheFailure value) cache,
    required TResult Function(MedicineConnectionTimeOutFailure value)
        connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MedicineUnknownFailure value)? unknown,
    TResult? Function(MedicineNotFoundFailure value)? notFound,
    TResult? Function(MedicineSerializationFailure value)? serialization,
    TResult? Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MedicineResponseFailure value)? response,
    TResult? Function(MedicineCancelFailure value)? cancel,
    TResult? Function(MedicineCacheFailure value)? cache,
    TResult? Function(MedicineConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MedicineUnknownFailure value)? unknown,
    TResult Function(MedicineNotFoundFailure value)? notFound,
    TResult Function(MedicineSerializationFailure value)? serialization,
    TResult Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MedicineResponseFailure value)? response,
    TResult Function(MedicineCancelFailure value)? cancel,
    TResult Function(MedicineCacheFailure value)? cache,
    TResult Function(MedicineConnectionTimeOutFailure value)? connectionTimeOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicineFailureCopyWith<$Res> {
  factory $MedicineFailureCopyWith(
          MedicineFailure value, $Res Function(MedicineFailure) then) =
      _$MedicineFailureCopyWithImpl<$Res, MedicineFailure>;
}

/// @nodoc
class _$MedicineFailureCopyWithImpl<$Res, $Val extends MedicineFailure>
    implements $MedicineFailureCopyWith<$Res> {
  _$MedicineFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MedicineUnknownFailureCopyWith<$Res> {
  factory _$$MedicineUnknownFailureCopyWith(_$MedicineUnknownFailure value,
          $Res Function(_$MedicineUnknownFailure) then) =
      __$$MedicineUnknownFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MedicineUnknownFailureCopyWithImpl<$Res>
    extends _$MedicineFailureCopyWithImpl<$Res, _$MedicineUnknownFailure>
    implements _$$MedicineUnknownFailureCopyWith<$Res> {
  __$$MedicineUnknownFailureCopyWithImpl(_$MedicineUnknownFailure _value,
      $Res Function(_$MedicineUnknownFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MedicineUnknownFailure implements MedicineUnknownFailure {
  const _$MedicineUnknownFailure();

  @override
  String toString() {
    return 'MedicineFailure.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MedicineUnknownFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MedicineUnknownFailure value) unknown,
    required TResult Function(MedicineNotFoundFailure value) notFound,
    required TResult Function(MedicineSerializationFailure value) serialization,
    required TResult Function(MedicineSendTimeoutFailure value) sendTimeout,
    required TResult Function(MedicineReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MedicineResponseFailure value) response,
    required TResult Function(MedicineCancelFailure value) cancel,
    required TResult Function(MedicineCacheFailure value) cache,
    required TResult Function(MedicineConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MedicineUnknownFailure value)? unknown,
    TResult? Function(MedicineNotFoundFailure value)? notFound,
    TResult? Function(MedicineSerializationFailure value)? serialization,
    TResult? Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MedicineResponseFailure value)? response,
    TResult? Function(MedicineCancelFailure value)? cancel,
    TResult? Function(MedicineCacheFailure value)? cache,
    TResult? Function(MedicineConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MedicineUnknownFailure value)? unknown,
    TResult Function(MedicineNotFoundFailure value)? notFound,
    TResult Function(MedicineSerializationFailure value)? serialization,
    TResult Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MedicineResponseFailure value)? response,
    TResult Function(MedicineCancelFailure value)? cancel,
    TResult Function(MedicineCacheFailure value)? cache,
    TResult Function(MedicineConnectionTimeOutFailure value)? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class MedicineUnknownFailure implements MedicineFailure {
  const factory MedicineUnknownFailure() = _$MedicineUnknownFailure;
}

/// @nodoc
abstract class _$$MedicineNotFoundFailureCopyWith<$Res> {
  factory _$$MedicineNotFoundFailureCopyWith(_$MedicineNotFoundFailure value,
          $Res Function(_$MedicineNotFoundFailure) then) =
      __$$MedicineNotFoundFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MedicineNotFoundFailureCopyWithImpl<$Res>
    extends _$MedicineFailureCopyWithImpl<$Res, _$MedicineNotFoundFailure>
    implements _$$MedicineNotFoundFailureCopyWith<$Res> {
  __$$MedicineNotFoundFailureCopyWithImpl(_$MedicineNotFoundFailure _value,
      $Res Function(_$MedicineNotFoundFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MedicineNotFoundFailure implements MedicineNotFoundFailure {
  const _$MedicineNotFoundFailure();

  @override
  String toString() {
    return 'MedicineFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MedicineNotFoundFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MedicineUnknownFailure value) unknown,
    required TResult Function(MedicineNotFoundFailure value) notFound,
    required TResult Function(MedicineSerializationFailure value) serialization,
    required TResult Function(MedicineSendTimeoutFailure value) sendTimeout,
    required TResult Function(MedicineReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MedicineResponseFailure value) response,
    required TResult Function(MedicineCancelFailure value) cancel,
    required TResult Function(MedicineCacheFailure value) cache,
    required TResult Function(MedicineConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MedicineUnknownFailure value)? unknown,
    TResult? Function(MedicineNotFoundFailure value)? notFound,
    TResult? Function(MedicineSerializationFailure value)? serialization,
    TResult? Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MedicineResponseFailure value)? response,
    TResult? Function(MedicineCancelFailure value)? cancel,
    TResult? Function(MedicineCacheFailure value)? cache,
    TResult? Function(MedicineConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MedicineUnknownFailure value)? unknown,
    TResult Function(MedicineNotFoundFailure value)? notFound,
    TResult Function(MedicineSerializationFailure value)? serialization,
    TResult Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MedicineResponseFailure value)? response,
    TResult Function(MedicineCancelFailure value)? cancel,
    TResult Function(MedicineCacheFailure value)? cache,
    TResult Function(MedicineConnectionTimeOutFailure value)? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class MedicineNotFoundFailure implements MedicineFailure {
  const factory MedicineNotFoundFailure() = _$MedicineNotFoundFailure;
}

/// @nodoc
abstract class _$$MedicineSerializationFailureCopyWith<$Res> {
  factory _$$MedicineSerializationFailureCopyWith(
          _$MedicineSerializationFailure value,
          $Res Function(_$MedicineSerializationFailure) then) =
      __$$MedicineSerializationFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MedicineSerializationFailureCopyWithImpl<$Res>
    extends _$MedicineFailureCopyWithImpl<$Res, _$MedicineSerializationFailure>
    implements _$$MedicineSerializationFailureCopyWith<$Res> {
  __$$MedicineSerializationFailureCopyWithImpl(
      _$MedicineSerializationFailure _value,
      $Res Function(_$MedicineSerializationFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MedicineSerializationFailure implements MedicineSerializationFailure {
  const _$MedicineSerializationFailure();

  @override
  String toString() {
    return 'MedicineFailure.serialization()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MedicineSerializationFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return serialization();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return serialization?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MedicineUnknownFailure value) unknown,
    required TResult Function(MedicineNotFoundFailure value) notFound,
    required TResult Function(MedicineSerializationFailure value) serialization,
    required TResult Function(MedicineSendTimeoutFailure value) sendTimeout,
    required TResult Function(MedicineReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MedicineResponseFailure value) response,
    required TResult Function(MedicineCancelFailure value) cancel,
    required TResult Function(MedicineCacheFailure value) cache,
    required TResult Function(MedicineConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return serialization(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MedicineUnknownFailure value)? unknown,
    TResult? Function(MedicineNotFoundFailure value)? notFound,
    TResult? Function(MedicineSerializationFailure value)? serialization,
    TResult? Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MedicineResponseFailure value)? response,
    TResult? Function(MedicineCancelFailure value)? cancel,
    TResult? Function(MedicineCacheFailure value)? cache,
    TResult? Function(MedicineConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return serialization?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MedicineUnknownFailure value)? unknown,
    TResult Function(MedicineNotFoundFailure value)? notFound,
    TResult Function(MedicineSerializationFailure value)? serialization,
    TResult Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MedicineResponseFailure value)? response,
    TResult Function(MedicineCancelFailure value)? cancel,
    TResult Function(MedicineCacheFailure value)? cache,
    TResult Function(MedicineConnectionTimeOutFailure value)? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization(this);
    }
    return orElse();
  }
}

abstract class MedicineSerializationFailure implements MedicineFailure {
  const factory MedicineSerializationFailure() = _$MedicineSerializationFailure;
}

/// @nodoc
abstract class _$$MedicineSendTimeoutFailureCopyWith<$Res> {
  factory _$$MedicineSendTimeoutFailureCopyWith(
          _$MedicineSendTimeoutFailure value,
          $Res Function(_$MedicineSendTimeoutFailure) then) =
      __$$MedicineSendTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MedicineSendTimeoutFailureCopyWithImpl<$Res>
    extends _$MedicineFailureCopyWithImpl<$Res, _$MedicineSendTimeoutFailure>
    implements _$$MedicineSendTimeoutFailureCopyWith<$Res> {
  __$$MedicineSendTimeoutFailureCopyWithImpl(
      _$MedicineSendTimeoutFailure _value,
      $Res Function(_$MedicineSendTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MedicineSendTimeoutFailure implements MedicineSendTimeoutFailure {
  const _$MedicineSendTimeoutFailure();

  @override
  String toString() {
    return 'MedicineFailure.sendTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MedicineSendTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return sendTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return sendTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MedicineUnknownFailure value) unknown,
    required TResult Function(MedicineNotFoundFailure value) notFound,
    required TResult Function(MedicineSerializationFailure value) serialization,
    required TResult Function(MedicineSendTimeoutFailure value) sendTimeout,
    required TResult Function(MedicineReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MedicineResponseFailure value) response,
    required TResult Function(MedicineCancelFailure value) cancel,
    required TResult Function(MedicineCacheFailure value) cache,
    required TResult Function(MedicineConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return sendTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MedicineUnknownFailure value)? unknown,
    TResult? Function(MedicineNotFoundFailure value)? notFound,
    TResult? Function(MedicineSerializationFailure value)? serialization,
    TResult? Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MedicineResponseFailure value)? response,
    TResult? Function(MedicineCancelFailure value)? cancel,
    TResult? Function(MedicineCacheFailure value)? cache,
    TResult? Function(MedicineConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return sendTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MedicineUnknownFailure value)? unknown,
    TResult Function(MedicineNotFoundFailure value)? notFound,
    TResult Function(MedicineSerializationFailure value)? serialization,
    TResult Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MedicineResponseFailure value)? response,
    TResult Function(MedicineCancelFailure value)? cancel,
    TResult Function(MedicineCacheFailure value)? cache,
    TResult Function(MedicineConnectionTimeOutFailure value)? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout(this);
    }
    return orElse();
  }
}

abstract class MedicineSendTimeoutFailure implements MedicineFailure {
  const factory MedicineSendTimeoutFailure() = _$MedicineSendTimeoutFailure;
}

/// @nodoc
abstract class _$$MedicineReceiveTimeoutFailureCopyWith<$Res> {
  factory _$$MedicineReceiveTimeoutFailureCopyWith(
          _$MedicineReceiveTimeoutFailure value,
          $Res Function(_$MedicineReceiveTimeoutFailure) then) =
      __$$MedicineReceiveTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MedicineReceiveTimeoutFailureCopyWithImpl<$Res>
    extends _$MedicineFailureCopyWithImpl<$Res, _$MedicineReceiveTimeoutFailure>
    implements _$$MedicineReceiveTimeoutFailureCopyWith<$Res> {
  __$$MedicineReceiveTimeoutFailureCopyWithImpl(
      _$MedicineReceiveTimeoutFailure _value,
      $Res Function(_$MedicineReceiveTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MedicineReceiveTimeoutFailure implements MedicineReceiveTimeoutFailure {
  const _$MedicineReceiveTimeoutFailure();

  @override
  String toString() {
    return 'MedicineFailure.receiveTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MedicineReceiveTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return receiveTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return receiveTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MedicineUnknownFailure value) unknown,
    required TResult Function(MedicineNotFoundFailure value) notFound,
    required TResult Function(MedicineSerializationFailure value) serialization,
    required TResult Function(MedicineSendTimeoutFailure value) sendTimeout,
    required TResult Function(MedicineReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MedicineResponseFailure value) response,
    required TResult Function(MedicineCancelFailure value) cancel,
    required TResult Function(MedicineCacheFailure value) cache,
    required TResult Function(MedicineConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return receiveTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MedicineUnknownFailure value)? unknown,
    TResult? Function(MedicineNotFoundFailure value)? notFound,
    TResult? Function(MedicineSerializationFailure value)? serialization,
    TResult? Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MedicineResponseFailure value)? response,
    TResult? Function(MedicineCancelFailure value)? cancel,
    TResult? Function(MedicineCacheFailure value)? cache,
    TResult? Function(MedicineConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return receiveTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MedicineUnknownFailure value)? unknown,
    TResult Function(MedicineNotFoundFailure value)? notFound,
    TResult Function(MedicineSerializationFailure value)? serialization,
    TResult Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MedicineResponseFailure value)? response,
    TResult Function(MedicineCancelFailure value)? cancel,
    TResult Function(MedicineCacheFailure value)? cache,
    TResult Function(MedicineConnectionTimeOutFailure value)? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout(this);
    }
    return orElse();
  }
}

abstract class MedicineReceiveTimeoutFailure implements MedicineFailure {
  const factory MedicineReceiveTimeoutFailure() =
      _$MedicineReceiveTimeoutFailure;
}

/// @nodoc
abstract class _$$MedicineResponseFailureCopyWith<$Res> {
  factory _$$MedicineResponseFailureCopyWith(_$MedicineResponseFailure value,
          $Res Function(_$MedicineResponseFailure) then) =
      __$$MedicineResponseFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MedicineResponseFailureCopyWithImpl<$Res>
    extends _$MedicineFailureCopyWithImpl<$Res, _$MedicineResponseFailure>
    implements _$$MedicineResponseFailureCopyWith<$Res> {
  __$$MedicineResponseFailureCopyWithImpl(_$MedicineResponseFailure _value,
      $Res Function(_$MedicineResponseFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MedicineResponseFailure implements MedicineResponseFailure {
  const _$MedicineResponseFailure();

  @override
  String toString() {
    return 'MedicineFailure.response()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MedicineResponseFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return response();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return response?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MedicineUnknownFailure value) unknown,
    required TResult Function(MedicineNotFoundFailure value) notFound,
    required TResult Function(MedicineSerializationFailure value) serialization,
    required TResult Function(MedicineSendTimeoutFailure value) sendTimeout,
    required TResult Function(MedicineReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MedicineResponseFailure value) response,
    required TResult Function(MedicineCancelFailure value) cancel,
    required TResult Function(MedicineCacheFailure value) cache,
    required TResult Function(MedicineConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return response(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MedicineUnknownFailure value)? unknown,
    TResult? Function(MedicineNotFoundFailure value)? notFound,
    TResult? Function(MedicineSerializationFailure value)? serialization,
    TResult? Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MedicineResponseFailure value)? response,
    TResult? Function(MedicineCancelFailure value)? cancel,
    TResult? Function(MedicineCacheFailure value)? cache,
    TResult? Function(MedicineConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return response?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MedicineUnknownFailure value)? unknown,
    TResult Function(MedicineNotFoundFailure value)? notFound,
    TResult Function(MedicineSerializationFailure value)? serialization,
    TResult Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MedicineResponseFailure value)? response,
    TResult Function(MedicineCancelFailure value)? cancel,
    TResult Function(MedicineCacheFailure value)? cache,
    TResult Function(MedicineConnectionTimeOutFailure value)? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response(this);
    }
    return orElse();
  }
}

abstract class MedicineResponseFailure implements MedicineFailure {
  const factory MedicineResponseFailure() = _$MedicineResponseFailure;
}

/// @nodoc
abstract class _$$MedicineCancelFailureCopyWith<$Res> {
  factory _$$MedicineCancelFailureCopyWith(_$MedicineCancelFailure value,
          $Res Function(_$MedicineCancelFailure) then) =
      __$$MedicineCancelFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MedicineCancelFailureCopyWithImpl<$Res>
    extends _$MedicineFailureCopyWithImpl<$Res, _$MedicineCancelFailure>
    implements _$$MedicineCancelFailureCopyWith<$Res> {
  __$$MedicineCancelFailureCopyWithImpl(_$MedicineCancelFailure _value,
      $Res Function(_$MedicineCancelFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MedicineCancelFailure implements MedicineCancelFailure {
  const _$MedicineCancelFailure();

  @override
  String toString() {
    return 'MedicineFailure.cancel()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MedicineCancelFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return cancel();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return cancel?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MedicineUnknownFailure value) unknown,
    required TResult Function(MedicineNotFoundFailure value) notFound,
    required TResult Function(MedicineSerializationFailure value) serialization,
    required TResult Function(MedicineSendTimeoutFailure value) sendTimeout,
    required TResult Function(MedicineReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MedicineResponseFailure value) response,
    required TResult Function(MedicineCancelFailure value) cancel,
    required TResult Function(MedicineCacheFailure value) cache,
    required TResult Function(MedicineConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return cancel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MedicineUnknownFailure value)? unknown,
    TResult? Function(MedicineNotFoundFailure value)? notFound,
    TResult? Function(MedicineSerializationFailure value)? serialization,
    TResult? Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MedicineResponseFailure value)? response,
    TResult? Function(MedicineCancelFailure value)? cancel,
    TResult? Function(MedicineCacheFailure value)? cache,
    TResult? Function(MedicineConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return cancel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MedicineUnknownFailure value)? unknown,
    TResult Function(MedicineNotFoundFailure value)? notFound,
    TResult Function(MedicineSerializationFailure value)? serialization,
    TResult Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MedicineResponseFailure value)? response,
    TResult Function(MedicineCancelFailure value)? cancel,
    TResult Function(MedicineCacheFailure value)? cache,
    TResult Function(MedicineConnectionTimeOutFailure value)? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel(this);
    }
    return orElse();
  }
}

abstract class MedicineCancelFailure implements MedicineFailure {
  const factory MedicineCancelFailure() = _$MedicineCancelFailure;
}

/// @nodoc
abstract class _$$MedicineCacheFailureCopyWith<$Res> {
  factory _$$MedicineCacheFailureCopyWith(_$MedicineCacheFailure value,
          $Res Function(_$MedicineCacheFailure) then) =
      __$$MedicineCacheFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MedicineCacheFailureCopyWithImpl<$Res>
    extends _$MedicineFailureCopyWithImpl<$Res, _$MedicineCacheFailure>
    implements _$$MedicineCacheFailureCopyWith<$Res> {
  __$$MedicineCacheFailureCopyWithImpl(_$MedicineCacheFailure _value,
      $Res Function(_$MedicineCacheFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MedicineCacheFailure implements MedicineCacheFailure {
  const _$MedicineCacheFailure();

  @override
  String toString() {
    return 'MedicineFailure.cache()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MedicineCacheFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return cache();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return cache?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MedicineUnknownFailure value) unknown,
    required TResult Function(MedicineNotFoundFailure value) notFound,
    required TResult Function(MedicineSerializationFailure value) serialization,
    required TResult Function(MedicineSendTimeoutFailure value) sendTimeout,
    required TResult Function(MedicineReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MedicineResponseFailure value) response,
    required TResult Function(MedicineCancelFailure value) cancel,
    required TResult Function(MedicineCacheFailure value) cache,
    required TResult Function(MedicineConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return cache(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MedicineUnknownFailure value)? unknown,
    TResult? Function(MedicineNotFoundFailure value)? notFound,
    TResult? Function(MedicineSerializationFailure value)? serialization,
    TResult? Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MedicineResponseFailure value)? response,
    TResult? Function(MedicineCancelFailure value)? cancel,
    TResult? Function(MedicineCacheFailure value)? cache,
    TResult? Function(MedicineConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return cache?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MedicineUnknownFailure value)? unknown,
    TResult Function(MedicineNotFoundFailure value)? notFound,
    TResult Function(MedicineSerializationFailure value)? serialization,
    TResult Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MedicineResponseFailure value)? response,
    TResult Function(MedicineCancelFailure value)? cancel,
    TResult Function(MedicineCacheFailure value)? cache,
    TResult Function(MedicineConnectionTimeOutFailure value)? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache(this);
    }
    return orElse();
  }
}

abstract class MedicineCacheFailure implements MedicineFailure {
  const factory MedicineCacheFailure() = _$MedicineCacheFailure;
}

/// @nodoc
abstract class _$$MedicineConnectionTimeOutFailureCopyWith<$Res> {
  factory _$$MedicineConnectionTimeOutFailureCopyWith(
          _$MedicineConnectionTimeOutFailure value,
          $Res Function(_$MedicineConnectionTimeOutFailure) then) =
      __$$MedicineConnectionTimeOutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MedicineConnectionTimeOutFailureCopyWithImpl<$Res>
    extends _$MedicineFailureCopyWithImpl<$Res,
        _$MedicineConnectionTimeOutFailure>
    implements _$$MedicineConnectionTimeOutFailureCopyWith<$Res> {
  __$$MedicineConnectionTimeOutFailureCopyWithImpl(
      _$MedicineConnectionTimeOutFailure _value,
      $Res Function(_$MedicineConnectionTimeOutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MedicineConnectionTimeOutFailure
    implements MedicineConnectionTimeOutFailure {
  const _$MedicineConnectionTimeOutFailure();

  @override
  String toString() {
    return 'MedicineFailure.connectionTimeOut()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MedicineConnectionTimeOutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return connectionTimeOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return connectionTimeOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (connectionTimeOut != null) {
      return connectionTimeOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MedicineUnknownFailure value) unknown,
    required TResult Function(MedicineNotFoundFailure value) notFound,
    required TResult Function(MedicineSerializationFailure value) serialization,
    required TResult Function(MedicineSendTimeoutFailure value) sendTimeout,
    required TResult Function(MedicineReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MedicineResponseFailure value) response,
    required TResult Function(MedicineCancelFailure value) cancel,
    required TResult Function(MedicineCacheFailure value) cache,
    required TResult Function(MedicineConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return connectionTimeOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MedicineUnknownFailure value)? unknown,
    TResult? Function(MedicineNotFoundFailure value)? notFound,
    TResult? Function(MedicineSerializationFailure value)? serialization,
    TResult? Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MedicineResponseFailure value)? response,
    TResult? Function(MedicineCancelFailure value)? cancel,
    TResult? Function(MedicineCacheFailure value)? cache,
    TResult? Function(MedicineConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return connectionTimeOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MedicineUnknownFailure value)? unknown,
    TResult Function(MedicineNotFoundFailure value)? notFound,
    TResult Function(MedicineSerializationFailure value)? serialization,
    TResult Function(MedicineSendTimeoutFailure value)? sendTimeout,
    TResult Function(MedicineReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MedicineResponseFailure value)? response,
    TResult Function(MedicineCancelFailure value)? cancel,
    TResult Function(MedicineCacheFailure value)? cache,
    TResult Function(MedicineConnectionTimeOutFailure value)? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (connectionTimeOut != null) {
      return connectionTimeOut(this);
    }
    return orElse();
  }
}

abstract class MedicineConnectionTimeOutFailure implements MedicineFailure {
  const factory MedicineConnectionTimeOutFailure() =
      _$MedicineConnectionTimeOutFailure;
}

/// @nodoc
mixin _$MeasurementFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MeasurementFailureCopyWith<$Res> {
  factory $MeasurementFailureCopyWith(
          MeasurementFailure value, $Res Function(MeasurementFailure) then) =
      _$MeasurementFailureCopyWithImpl<$Res, MeasurementFailure>;
}

/// @nodoc
class _$MeasurementFailureCopyWithImpl<$Res, $Val extends MeasurementFailure>
    implements $MeasurementFailureCopyWith<$Res> {
  _$MeasurementFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MeasurementUnknownFailureCopyWith<$Res> {
  factory _$$MeasurementUnknownFailureCopyWith(
          _$MeasurementUnknownFailure value,
          $Res Function(_$MeasurementUnknownFailure) then) =
      __$$MeasurementUnknownFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementUnknownFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MeasurementUnknownFailure>
    implements _$$MeasurementUnknownFailureCopyWith<$Res> {
  __$$MeasurementUnknownFailureCopyWithImpl(_$MeasurementUnknownFailure _value,
      $Res Function(_$MeasurementUnknownFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementUnknownFailure implements MeasurementUnknownFailure {
  const _$MeasurementUnknownFailure();

  @override
  String toString() {
    return 'MeasurementFailure.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementUnknownFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class MeasurementUnknownFailure implements MeasurementFailure {
  const factory MeasurementUnknownFailure() = _$MeasurementUnknownFailure;
}

/// @nodoc
abstract class _$$MeasurementNotFoundFailureCopyWith<$Res> {
  factory _$$MeasurementNotFoundFailureCopyWith(
          _$MeasurementNotFoundFailure value,
          $Res Function(_$MeasurementNotFoundFailure) then) =
      __$$MeasurementNotFoundFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementNotFoundFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MeasurementNotFoundFailure>
    implements _$$MeasurementNotFoundFailureCopyWith<$Res> {
  __$$MeasurementNotFoundFailureCopyWithImpl(
      _$MeasurementNotFoundFailure _value,
      $Res Function(_$MeasurementNotFoundFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementNotFoundFailure implements MeasurementNotFoundFailure {
  const _$MeasurementNotFoundFailure();

  @override
  String toString() {
    return 'MeasurementFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementNotFoundFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class MeasurementNotFoundFailure implements MeasurementFailure {
  const factory MeasurementNotFoundFailure() = _$MeasurementNotFoundFailure;
}

/// @nodoc
abstract class _$$MeasurementSerializationFailureCopyWith<$Res> {
  factory _$$MeasurementSerializationFailureCopyWith(
          _$MeasurementSerializationFailure value,
          $Res Function(_$MeasurementSerializationFailure) then) =
      __$$MeasurementSerializationFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementSerializationFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res,
        _$MeasurementSerializationFailure>
    implements _$$MeasurementSerializationFailureCopyWith<$Res> {
  __$$MeasurementSerializationFailureCopyWithImpl(
      _$MeasurementSerializationFailure _value,
      $Res Function(_$MeasurementSerializationFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementSerializationFailure
    implements MeasurementSerializationFailure {
  const _$MeasurementSerializationFailure();

  @override
  String toString() {
    return 'MeasurementFailure.serialization()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementSerializationFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return serialization();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return serialization?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return serialization(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return serialization?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization(this);
    }
    return orElse();
  }
}

abstract class MeasurementSerializationFailure implements MeasurementFailure {
  const factory MeasurementSerializationFailure() =
      _$MeasurementSerializationFailure;
}

/// @nodoc
abstract class _$$MeasurementSendTimeoutFailureCopyWith<$Res> {
  factory _$$MeasurementSendTimeoutFailureCopyWith(
          _$MeasurementSendTimeoutFailure value,
          $Res Function(_$MeasurementSendTimeoutFailure) then) =
      __$$MeasurementSendTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementSendTimeoutFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res,
        _$MeasurementSendTimeoutFailure>
    implements _$$MeasurementSendTimeoutFailureCopyWith<$Res> {
  __$$MeasurementSendTimeoutFailureCopyWithImpl(
      _$MeasurementSendTimeoutFailure _value,
      $Res Function(_$MeasurementSendTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementSendTimeoutFailure implements MeasurementSendTimeoutFailure {
  const _$MeasurementSendTimeoutFailure();

  @override
  String toString() {
    return 'MeasurementFailure.sendTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementSendTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return sendTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return sendTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return sendTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return sendTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout(this);
    }
    return orElse();
  }
}

abstract class MeasurementSendTimeoutFailure implements MeasurementFailure {
  const factory MeasurementSendTimeoutFailure() =
      _$MeasurementSendTimeoutFailure;
}

/// @nodoc
abstract class _$$MeasurementReceiveTimeoutFailureCopyWith<$Res> {
  factory _$$MeasurementReceiveTimeoutFailureCopyWith(
          _$MeasurementReceiveTimeoutFailure value,
          $Res Function(_$MeasurementReceiveTimeoutFailure) then) =
      __$$MeasurementReceiveTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementReceiveTimeoutFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res,
        _$MeasurementReceiveTimeoutFailure>
    implements _$$MeasurementReceiveTimeoutFailureCopyWith<$Res> {
  __$$MeasurementReceiveTimeoutFailureCopyWithImpl(
      _$MeasurementReceiveTimeoutFailure _value,
      $Res Function(_$MeasurementReceiveTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementReceiveTimeoutFailure
    implements MeasurementReceiveTimeoutFailure {
  const _$MeasurementReceiveTimeoutFailure();

  @override
  String toString() {
    return 'MeasurementFailure.receiveTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementReceiveTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return receiveTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return receiveTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return receiveTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return receiveTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout(this);
    }
    return orElse();
  }
}

abstract class MeasurementReceiveTimeoutFailure implements MeasurementFailure {
  const factory MeasurementReceiveTimeoutFailure() =
      _$MeasurementReceiveTimeoutFailure;
}

/// @nodoc
abstract class _$$MeasurementResponseFailureCopyWith<$Res> {
  factory _$$MeasurementResponseFailureCopyWith(
          _$MeasurementResponseFailure value,
          $Res Function(_$MeasurementResponseFailure) then) =
      __$$MeasurementResponseFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementResponseFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MeasurementResponseFailure>
    implements _$$MeasurementResponseFailureCopyWith<$Res> {
  __$$MeasurementResponseFailureCopyWithImpl(
      _$MeasurementResponseFailure _value,
      $Res Function(_$MeasurementResponseFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementResponseFailure implements MeasurementResponseFailure {
  const _$MeasurementResponseFailure();

  @override
  String toString() {
    return 'MeasurementFailure.response()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementResponseFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return response();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return response?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return response(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return response?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response(this);
    }
    return orElse();
  }
}

abstract class MeasurementResponseFailure implements MeasurementFailure {
  const factory MeasurementResponseFailure() = _$MeasurementResponseFailure;
}

/// @nodoc
abstract class _$$MeasurementCancelFailureCopyWith<$Res> {
  factory _$$MeasurementCancelFailureCopyWith(_$MeasurementCancelFailure value,
          $Res Function(_$MeasurementCancelFailure) then) =
      __$$MeasurementCancelFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementCancelFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MeasurementCancelFailure>
    implements _$$MeasurementCancelFailureCopyWith<$Res> {
  __$$MeasurementCancelFailureCopyWithImpl(_$MeasurementCancelFailure _value,
      $Res Function(_$MeasurementCancelFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementCancelFailure implements MeasurementCancelFailure {
  const _$MeasurementCancelFailure();

  @override
  String toString() {
    return 'MeasurementFailure.cancel()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementCancelFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return cancel();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return cancel?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return cancel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return cancel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel(this);
    }
    return orElse();
  }
}

abstract class MeasurementCancelFailure implements MeasurementFailure {
  const factory MeasurementCancelFailure() = _$MeasurementCancelFailure;
}

/// @nodoc
abstract class _$$MeasurementCacheFailureCopyWith<$Res> {
  factory _$$MeasurementCacheFailureCopyWith(_$MeasurementCacheFailure value,
          $Res Function(_$MeasurementCacheFailure) then) =
      __$$MeasurementCacheFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementCacheFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MeasurementCacheFailure>
    implements _$$MeasurementCacheFailureCopyWith<$Res> {
  __$$MeasurementCacheFailureCopyWithImpl(_$MeasurementCacheFailure _value,
      $Res Function(_$MeasurementCacheFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementCacheFailure implements MeasurementCacheFailure {
  const _$MeasurementCacheFailure();

  @override
  String toString() {
    return 'MeasurementFailure.cache()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementCacheFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return cache();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return cache?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return cache(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return cache?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache(this);
    }
    return orElse();
  }
}

abstract class MeasurementCacheFailure implements MeasurementFailure {
  const factory MeasurementCacheFailure() = _$MeasurementCacheFailure;
}

/// @nodoc
abstract class _$$MeasurementConnectionTimeOutFailureCopyWith<$Res> {
  factory _$$MeasurementConnectionTimeOutFailureCopyWith(
          _$MeasurementConnectionTimeOutFailure value,
          $Res Function(_$MeasurementConnectionTimeOutFailure) then) =
      __$$MeasurementConnectionTimeOutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MeasurementConnectionTimeOutFailureCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res,
        _$MeasurementConnectionTimeOutFailure>
    implements _$$MeasurementConnectionTimeOutFailureCopyWith<$Res> {
  __$$MeasurementConnectionTimeOutFailureCopyWithImpl(
      _$MeasurementConnectionTimeOutFailure _value,
      $Res Function(_$MeasurementConnectionTimeOutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MeasurementConnectionTimeOutFailure
    implements MeasurementConnectionTimeOutFailure {
  const _$MeasurementConnectionTimeOutFailure();

  @override
  String toString() {
    return 'MeasurementFailure.connectionTimeOut()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasurementConnectionTimeOutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() notFound,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() connectionTimeOut,
  }) {
    return connectionTimeOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? notFound,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? connectionTimeOut,
  }) {
    return connectionTimeOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? notFound,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? connectionTimeOut,
    required TResult orElse(),
  }) {
    if (connectionTimeOut != null) {
      return connectionTimeOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasurementUnknownFailure value) unknown,
    required TResult Function(MeasurementNotFoundFailure value) notFound,
    required TResult Function(MeasurementSerializationFailure value)
        serialization,
    required TResult Function(MeasurementSendTimeoutFailure value) sendTimeout,
    required TResult Function(MeasurementReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(MeasurementResponseFailure value) response,
    required TResult Function(MeasurementCancelFailure value) cancel,
    required TResult Function(MeasurementCacheFailure value) cache,
    required TResult Function(MeasurementConnectionTimeOutFailure value)
        connectionTimeOut,
  }) {
    return connectionTimeOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasurementUnknownFailure value)? unknown,
    TResult? Function(MeasurementNotFoundFailure value)? notFound,
    TResult? Function(MeasurementSerializationFailure value)? serialization,
    TResult? Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult? Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(MeasurementResponseFailure value)? response,
    TResult? Function(MeasurementCancelFailure value)? cancel,
    TResult? Function(MeasurementCacheFailure value)? cache,
    TResult? Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
  }) {
    return connectionTimeOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasurementUnknownFailure value)? unknown,
    TResult Function(MeasurementNotFoundFailure value)? notFound,
    TResult Function(MeasurementSerializationFailure value)? serialization,
    TResult Function(MeasurementSendTimeoutFailure value)? sendTimeout,
    TResult Function(MeasurementReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(MeasurementResponseFailure value)? response,
    TResult Function(MeasurementCancelFailure value)? cancel,
    TResult Function(MeasurementCacheFailure value)? cache,
    TResult Function(MeasurementConnectionTimeOutFailure value)?
        connectionTimeOut,
    required TResult orElse(),
  }) {
    if (connectionTimeOut != null) {
      return connectionTimeOut(this);
    }
    return orElse();
  }
}

abstract class MeasurementConnectionTimeOutFailure
    implements MeasurementFailure {
  const factory MeasurementConnectionTimeOutFailure() =
      _$MeasurementConnectionTimeOutFailure;
}
