// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$NotificationFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotificationFailureCopyWith<$Res> {
  factory $NotificationFailureCopyWith(
          NotificationFailure value, $Res Function(NotificationFailure) then) =
      _$NotificationFailureCopyWithImpl<$Res, NotificationFailure>;
}

/// @nodoc
class _$NotificationFailureCopyWithImpl<$Res, $Val extends NotificationFailure>
    implements $NotificationFailureCopyWith<$Res> {
  _$NotificationFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NotificationNotFoundFailureCopyWith<$Res> {
  factory _$$NotificationNotFoundFailureCopyWith(
          _$NotificationNotFoundFailure value,
          $Res Function(_$NotificationNotFoundFailure) then) =
      __$$NotificationNotFoundFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationNotFoundFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res,
        _$NotificationNotFoundFailure>
    implements _$$NotificationNotFoundFailureCopyWith<$Res> {
  __$$NotificationNotFoundFailureCopyWithImpl(
      _$NotificationNotFoundFailure _value,
      $Res Function(_$NotificationNotFoundFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationNotFoundFailure implements NotificationNotFoundFailure {
  const _$NotificationNotFoundFailure();

  @override
  String toString() {
    return 'NotificationFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationNotFoundFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class NotificationNotFoundFailure implements NotificationFailure {
  const factory NotificationNotFoundFailure() = _$NotificationNotFoundFailure;
}

/// @nodoc
abstract class _$$NotificationTimeoutFailureCopyWith<$Res> {
  factory _$$NotificationTimeoutFailureCopyWith(
          _$NotificationTimeoutFailure value,
          $Res Function(_$NotificationTimeoutFailure) then) =
      __$$NotificationTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationTimeoutFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res,
        _$NotificationTimeoutFailure>
    implements _$$NotificationTimeoutFailureCopyWith<$Res> {
  __$$NotificationTimeoutFailureCopyWithImpl(
      _$NotificationTimeoutFailure _value,
      $Res Function(_$NotificationTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationTimeoutFailure implements NotificationTimeoutFailure {
  const _$NotificationTimeoutFailure();

  @override
  String toString() {
    return 'NotificationFailure.timeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return timeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return timeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return timeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return timeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout(this);
    }
    return orElse();
  }
}

abstract class NotificationTimeoutFailure implements NotificationFailure {
  const factory NotificationTimeoutFailure() = _$NotificationTimeoutFailure;
}

/// @nodoc
abstract class _$$NotificationSerializationFailureCopyWith<$Res> {
  factory _$$NotificationSerializationFailureCopyWith(
          _$NotificationSerializationFailure value,
          $Res Function(_$NotificationSerializationFailure) then) =
      __$$NotificationSerializationFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationSerializationFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res,
        _$NotificationSerializationFailure>
    implements _$$NotificationSerializationFailureCopyWith<$Res> {
  __$$NotificationSerializationFailureCopyWithImpl(
      _$NotificationSerializationFailure _value,
      $Res Function(_$NotificationSerializationFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationSerializationFailure
    implements NotificationSerializationFailure {
  const _$NotificationSerializationFailure();

  @override
  String toString() {
    return 'NotificationFailure.serialization()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationSerializationFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return serialization();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return serialization?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return serialization(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return serialization?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization(this);
    }
    return orElse();
  }
}

abstract class NotificationSerializationFailure implements NotificationFailure {
  const factory NotificationSerializationFailure() =
      _$NotificationSerializationFailure;
}

/// @nodoc
abstract class _$$NotificationSendTimeoutFailureCopyWith<$Res> {
  factory _$$NotificationSendTimeoutFailureCopyWith(
          _$NotificationSendTimeoutFailure value,
          $Res Function(_$NotificationSendTimeoutFailure) then) =
      __$$NotificationSendTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationSendTimeoutFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res,
        _$NotificationSendTimeoutFailure>
    implements _$$NotificationSendTimeoutFailureCopyWith<$Res> {
  __$$NotificationSendTimeoutFailureCopyWithImpl(
      _$NotificationSendTimeoutFailure _value,
      $Res Function(_$NotificationSendTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationSendTimeoutFailure
    implements NotificationSendTimeoutFailure {
  const _$NotificationSendTimeoutFailure();

  @override
  String toString() {
    return 'NotificationFailure.sendTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationSendTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return sendTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return sendTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return sendTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return sendTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout(this);
    }
    return orElse();
  }
}

abstract class NotificationSendTimeoutFailure implements NotificationFailure {
  const factory NotificationSendTimeoutFailure() =
      _$NotificationSendTimeoutFailure;
}

/// @nodoc
abstract class _$$NotificationReceiveTimeoutFailureCopyWith<$Res> {
  factory _$$NotificationReceiveTimeoutFailureCopyWith(
          _$NotificationReceiveTimeoutFailure value,
          $Res Function(_$NotificationReceiveTimeoutFailure) then) =
      __$$NotificationReceiveTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationReceiveTimeoutFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res,
        _$NotificationReceiveTimeoutFailure>
    implements _$$NotificationReceiveTimeoutFailureCopyWith<$Res> {
  __$$NotificationReceiveTimeoutFailureCopyWithImpl(
      _$NotificationReceiveTimeoutFailure _value,
      $Res Function(_$NotificationReceiveTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationReceiveTimeoutFailure
    implements NotificationReceiveTimeoutFailure {
  const _$NotificationReceiveTimeoutFailure();

  @override
  String toString() {
    return 'NotificationFailure.receiveTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationReceiveTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return receiveTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return receiveTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return receiveTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return receiveTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout(this);
    }
    return orElse();
  }
}

abstract class NotificationReceiveTimeoutFailure
    implements NotificationFailure {
  const factory NotificationReceiveTimeoutFailure() =
      _$NotificationReceiveTimeoutFailure;
}

/// @nodoc
abstract class _$$NotificationResponseFailureCopyWith<$Res> {
  factory _$$NotificationResponseFailureCopyWith(
          _$NotificationResponseFailure value,
          $Res Function(_$NotificationResponseFailure) then) =
      __$$NotificationResponseFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationResponseFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res,
        _$NotificationResponseFailure>
    implements _$$NotificationResponseFailureCopyWith<$Res> {
  __$$NotificationResponseFailureCopyWithImpl(
      _$NotificationResponseFailure _value,
      $Res Function(_$NotificationResponseFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationResponseFailure implements NotificationResponseFailure {
  const _$NotificationResponseFailure();

  @override
  String toString() {
    return 'NotificationFailure.response()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationResponseFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return response();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return response?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return response(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return response?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response(this);
    }
    return orElse();
  }
}

abstract class NotificationResponseFailure implements NotificationFailure {
  const factory NotificationResponseFailure() = _$NotificationResponseFailure;
}

/// @nodoc
abstract class _$$NotificationConnectionTimeOutFailureCopyWith<$Res> {
  factory _$$NotificationConnectionTimeOutFailureCopyWith(
          _$NotificationConnectionTimeOutFailure value,
          $Res Function(_$NotificationConnectionTimeOutFailure) then) =
      __$$NotificationConnectionTimeOutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationConnectionTimeOutFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res,
        _$NotificationConnectionTimeOutFailure>
    implements _$$NotificationConnectionTimeOutFailureCopyWith<$Res> {
  __$$NotificationConnectionTimeOutFailureCopyWithImpl(
      _$NotificationConnectionTimeOutFailure _value,
      $Res Function(_$NotificationConnectionTimeOutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationConnectionTimeOutFailure
    implements NotificationConnectionTimeOutFailure {
  const _$NotificationConnectionTimeOutFailure();

  @override
  String toString() {
    return 'NotificationFailure.connectionTimeOut()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationConnectionTimeOutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return connectionTimeOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return connectionTimeOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (connectionTimeOut != null) {
      return connectionTimeOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return connectionTimeOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return connectionTimeOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (connectionTimeOut != null) {
      return connectionTimeOut(this);
    }
    return orElse();
  }
}

abstract class NotificationConnectionTimeOutFailure
    implements NotificationFailure {
  const factory NotificationConnectionTimeOutFailure() =
      _$NotificationConnectionTimeOutFailure;
}

/// @nodoc
abstract class _$$NotificationCancelFailureCopyWith<$Res> {
  factory _$$NotificationCancelFailureCopyWith(
          _$NotificationCancelFailure value,
          $Res Function(_$NotificationCancelFailure) then) =
      __$$NotificationCancelFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationCancelFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res, _$NotificationCancelFailure>
    implements _$$NotificationCancelFailureCopyWith<$Res> {
  __$$NotificationCancelFailureCopyWithImpl(_$NotificationCancelFailure _value,
      $Res Function(_$NotificationCancelFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationCancelFailure implements NotificationCancelFailure {
  const _$NotificationCancelFailure();

  @override
  String toString() {
    return 'NotificationFailure.cancel()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationCancelFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return cancel();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return cancel?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return cancel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return cancel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel(this);
    }
    return orElse();
  }
}

abstract class NotificationCancelFailure implements NotificationFailure {
  const factory NotificationCancelFailure() = _$NotificationCancelFailure;
}

/// @nodoc
abstract class _$$NotificationCacheFailureCopyWith<$Res> {
  factory _$$NotificationCacheFailureCopyWith(_$NotificationCacheFailure value,
          $Res Function(_$NotificationCacheFailure) then) =
      __$$NotificationCacheFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationCacheFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res, _$NotificationCacheFailure>
    implements _$$NotificationCacheFailureCopyWith<$Res> {
  __$$NotificationCacheFailureCopyWithImpl(_$NotificationCacheFailure _value,
      $Res Function(_$NotificationCacheFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationCacheFailure implements NotificationCacheFailure {
  const _$NotificationCacheFailure();

  @override
  String toString() {
    return 'NotificationFailure.cache()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationCacheFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return cache();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return cache?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return cache(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return cache?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache(this);
    }
    return orElse();
  }
}

abstract class NotificationCacheFailure implements NotificationFailure {
  const factory NotificationCacheFailure() = _$NotificationCacheFailure;
}

/// @nodoc
abstract class _$$NotificationUnknownFailureCopyWith<$Res> {
  factory _$$NotificationUnknownFailureCopyWith(
          _$NotificationUnknownFailure value,
          $Res Function(_$NotificationUnknownFailure) then) =
      __$$NotificationUnknownFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationUnknownFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res,
        _$NotificationUnknownFailure>
    implements _$$NotificationUnknownFailureCopyWith<$Res> {
  __$$NotificationUnknownFailureCopyWithImpl(
      _$NotificationUnknownFailure _value,
      $Res Function(_$NotificationUnknownFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationUnknownFailure implements NotificationUnknownFailure {
  const _$NotificationUnknownFailure();

  @override
  String toString() {
    return 'NotificationFailure.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationUnknownFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class NotificationUnknownFailure implements NotificationFailure {
  const factory NotificationUnknownFailure() = _$NotificationUnknownFailure;
}

/// @nodoc
abstract class _$$NotificationAlreadyExistsFailureCopyWith<$Res> {
  factory _$$NotificationAlreadyExistsFailureCopyWith(
          _$NotificationAlreadyExistsFailure value,
          $Res Function(_$NotificationAlreadyExistsFailure) then) =
      __$$NotificationAlreadyExistsFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationAlreadyExistsFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res,
        _$NotificationAlreadyExistsFailure>
    implements _$$NotificationAlreadyExistsFailureCopyWith<$Res> {
  __$$NotificationAlreadyExistsFailureCopyWithImpl(
      _$NotificationAlreadyExistsFailure _value,
      $Res Function(_$NotificationAlreadyExistsFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationAlreadyExistsFailure
    implements NotificationAlreadyExistsFailure {
  const _$NotificationAlreadyExistsFailure();

  @override
  String toString() {
    return 'NotificationFailure.alreadyExists()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationAlreadyExistsFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return alreadyExists();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return alreadyExists?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (alreadyExists != null) {
      return alreadyExists();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return alreadyExists(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return alreadyExists?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (alreadyExists != null) {
      return alreadyExists(this);
    }
    return orElse();
  }
}

abstract class NotificationAlreadyExistsFailure implements NotificationFailure {
  const factory NotificationAlreadyExistsFailure() =
      _$NotificationAlreadyExistsFailure;
}

/// @nodoc
abstract class _$$NotificationDoesNotExistFailureCopyWith<$Res> {
  factory _$$NotificationDoesNotExistFailureCopyWith(
          _$NotificationDoesNotExistFailure value,
          $Res Function(_$NotificationDoesNotExistFailure) then) =
      __$$NotificationDoesNotExistFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationDoesNotExistFailureCopyWithImpl<$Res>
    extends _$NotificationFailureCopyWithImpl<$Res,
        _$NotificationDoesNotExistFailure>
    implements _$$NotificationDoesNotExistFailureCopyWith<$Res> {
  __$$NotificationDoesNotExistFailureCopyWithImpl(
      _$NotificationDoesNotExistFailure _value,
      $Res Function(_$NotificationDoesNotExistFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotificationDoesNotExistFailure
    implements NotificationDoesNotExistFailure {
  const _$NotificationDoesNotExistFailure();

  @override
  String toString() {
    return 'NotificationFailure.doesNotExist()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotificationDoesNotExistFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() connectionTimeOut,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return doesNotExist();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? connectionTimeOut,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return doesNotExist?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? connectionTimeOut,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (doesNotExist != null) {
      return doesNotExist();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotificationNotFoundFailure value) notFound,
    required TResult Function(NotificationTimeoutFailure value) timeout,
    required TResult Function(NotificationSerializationFailure value)
        serialization,
    required TResult Function(NotificationSendTimeoutFailure value) sendTimeout,
    required TResult Function(NotificationReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(NotificationResponseFailure value) response,
    required TResult Function(NotificationConnectionTimeOutFailure value)
        connectionTimeOut,
    required TResult Function(NotificationCancelFailure value) cancel,
    required TResult Function(NotificationCacheFailure value) cache,
    required TResult Function(NotificationUnknownFailure value) unknown,
    required TResult Function(NotificationAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(NotificationDoesNotExistFailure value)
        doesNotExist,
  }) {
    return doesNotExist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotificationNotFoundFailure value)? notFound,
    TResult? Function(NotificationTimeoutFailure value)? timeout,
    TResult? Function(NotificationSerializationFailure value)? serialization,
    TResult? Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult? Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(NotificationResponseFailure value)? response,
    TResult? Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult? Function(NotificationCancelFailure value)? cancel,
    TResult? Function(NotificationCacheFailure value)? cache,
    TResult? Function(NotificationUnknownFailure value)? unknown,
    TResult? Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(NotificationDoesNotExistFailure value)? doesNotExist,
  }) {
    return doesNotExist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotificationNotFoundFailure value)? notFound,
    TResult Function(NotificationTimeoutFailure value)? timeout,
    TResult Function(NotificationSerializationFailure value)? serialization,
    TResult Function(NotificationSendTimeoutFailure value)? sendTimeout,
    TResult Function(NotificationReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(NotificationResponseFailure value)? response,
    TResult Function(NotificationConnectionTimeOutFailure value)?
        connectionTimeOut,
    TResult Function(NotificationCancelFailure value)? cancel,
    TResult Function(NotificationCacheFailure value)? cache,
    TResult Function(NotificationUnknownFailure value)? unknown,
    TResult Function(NotificationAlreadyExistsFailure value)? alreadyExists,
    TResult Function(NotificationDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (doesNotExist != null) {
      return doesNotExist(this);
    }
    return orElse();
  }
}

abstract class NotificationDoesNotExistFailure implements NotificationFailure {
  const factory NotificationDoesNotExistFailure() =
      _$NotificationDoesNotExistFailure;
}
