// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PredictionFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PredictionFailureCopyWith<$Res> {
  factory $PredictionFailureCopyWith(
          PredictionFailure value, $Res Function(PredictionFailure) then) =
      _$PredictionFailureCopyWithImpl<$Res, PredictionFailure>;
}

/// @nodoc
class _$PredictionFailureCopyWithImpl<$Res, $Val extends PredictionFailure>
    implements $PredictionFailureCopyWith<$Res> {
  _$PredictionFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PredictionNotFoundFailureCopyWith<$Res> {
  factory _$$PredictionNotFoundFailureCopyWith(
          _$PredictionNotFoundFailure value,
          $Res Function(_$PredictionNotFoundFailure) then) =
      __$$PredictionNotFoundFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PredictionNotFoundFailureCopyWithImpl<$Res>
    extends _$PredictionFailureCopyWithImpl<$Res, _$PredictionNotFoundFailure>
    implements _$$PredictionNotFoundFailureCopyWith<$Res> {
  __$$PredictionNotFoundFailureCopyWithImpl(_$PredictionNotFoundFailure _value,
      $Res Function(_$PredictionNotFoundFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PredictionNotFoundFailure implements PredictionNotFoundFailure {
  const _$PredictionNotFoundFailure();

  @override
  String toString() {
    return 'PredictionFailure.notFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PredictionNotFoundFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return notFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return notFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) {
    return notFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) {
    return notFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (notFound != null) {
      return notFound(this);
    }
    return orElse();
  }
}

abstract class PredictionNotFoundFailure implements PredictionFailure {
  const factory PredictionNotFoundFailure() = _$PredictionNotFoundFailure;
}

/// @nodoc
abstract class _$$PredictionTimeoutFailureCopyWith<$Res> {
  factory _$$PredictionTimeoutFailureCopyWith(_$PredictionTimeoutFailure value,
          $Res Function(_$PredictionTimeoutFailure) then) =
      __$$PredictionTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PredictionTimeoutFailureCopyWithImpl<$Res>
    extends _$PredictionFailureCopyWithImpl<$Res, _$PredictionTimeoutFailure>
    implements _$$PredictionTimeoutFailureCopyWith<$Res> {
  __$$PredictionTimeoutFailureCopyWithImpl(_$PredictionTimeoutFailure _value,
      $Res Function(_$PredictionTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PredictionTimeoutFailure implements PredictionTimeoutFailure {
  const _$PredictionTimeoutFailure();

  @override
  String toString() {
    return 'PredictionFailure.timeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PredictionTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return timeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return timeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) {
    return timeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) {
    return timeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (timeout != null) {
      return timeout(this);
    }
    return orElse();
  }
}

abstract class PredictionTimeoutFailure implements PredictionFailure {
  const factory PredictionTimeoutFailure() = _$PredictionTimeoutFailure;
}

/// @nodoc
abstract class _$$PredictionSerializationFailureCopyWith<$Res> {
  factory _$$PredictionSerializationFailureCopyWith(
          _$PredictionSerializationFailure value,
          $Res Function(_$PredictionSerializationFailure) then) =
      __$$PredictionSerializationFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PredictionSerializationFailureCopyWithImpl<$Res>
    extends _$PredictionFailureCopyWithImpl<$Res,
        _$PredictionSerializationFailure>
    implements _$$PredictionSerializationFailureCopyWith<$Res> {
  __$$PredictionSerializationFailureCopyWithImpl(
      _$PredictionSerializationFailure _value,
      $Res Function(_$PredictionSerializationFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PredictionSerializationFailure
    implements PredictionSerializationFailure {
  const _$PredictionSerializationFailure();

  @override
  String toString() {
    return 'PredictionFailure.serialization()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PredictionSerializationFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return serialization();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return serialization?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) {
    return serialization(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) {
    return serialization?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (serialization != null) {
      return serialization(this);
    }
    return orElse();
  }
}

abstract class PredictionSerializationFailure implements PredictionFailure {
  const factory PredictionSerializationFailure() =
      _$PredictionSerializationFailure;
}

/// @nodoc
abstract class _$$PredictionSendTimeoutFailureCopyWith<$Res> {
  factory _$$PredictionSendTimeoutFailureCopyWith(
          _$PredictionSendTimeoutFailure value,
          $Res Function(_$PredictionSendTimeoutFailure) then) =
      __$$PredictionSendTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PredictionSendTimeoutFailureCopyWithImpl<$Res>
    extends _$PredictionFailureCopyWithImpl<$Res,
        _$PredictionSendTimeoutFailure>
    implements _$$PredictionSendTimeoutFailureCopyWith<$Res> {
  __$$PredictionSendTimeoutFailureCopyWithImpl(
      _$PredictionSendTimeoutFailure _value,
      $Res Function(_$PredictionSendTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PredictionSendTimeoutFailure implements PredictionSendTimeoutFailure {
  const _$PredictionSendTimeoutFailure();

  @override
  String toString() {
    return 'PredictionFailure.sendTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PredictionSendTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return sendTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return sendTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) {
    return sendTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) {
    return sendTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout(this);
    }
    return orElse();
  }
}

abstract class PredictionSendTimeoutFailure implements PredictionFailure {
  const factory PredictionSendTimeoutFailure() = _$PredictionSendTimeoutFailure;
}

/// @nodoc
abstract class _$$PredictionReceiveTimeoutFailureCopyWith<$Res> {
  factory _$$PredictionReceiveTimeoutFailureCopyWith(
          _$PredictionReceiveTimeoutFailure value,
          $Res Function(_$PredictionReceiveTimeoutFailure) then) =
      __$$PredictionReceiveTimeoutFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PredictionReceiveTimeoutFailureCopyWithImpl<$Res>
    extends _$PredictionFailureCopyWithImpl<$Res,
        _$PredictionReceiveTimeoutFailure>
    implements _$$PredictionReceiveTimeoutFailureCopyWith<$Res> {
  __$$PredictionReceiveTimeoutFailureCopyWithImpl(
      _$PredictionReceiveTimeoutFailure _value,
      $Res Function(_$PredictionReceiveTimeoutFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PredictionReceiveTimeoutFailure
    implements PredictionReceiveTimeoutFailure {
  const _$PredictionReceiveTimeoutFailure();

  @override
  String toString() {
    return 'PredictionFailure.receiveTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PredictionReceiveTimeoutFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return receiveTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return receiveTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) {
    return receiveTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) {
    return receiveTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout(this);
    }
    return orElse();
  }
}

abstract class PredictionReceiveTimeoutFailure implements PredictionFailure {
  const factory PredictionReceiveTimeoutFailure() =
      _$PredictionReceiveTimeoutFailure;
}

/// @nodoc
abstract class _$$PredictionResponseFailureCopyWith<$Res> {
  factory _$$PredictionResponseFailureCopyWith(
          _$PredictionResponseFailure value,
          $Res Function(_$PredictionResponseFailure) then) =
      __$$PredictionResponseFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PredictionResponseFailureCopyWithImpl<$Res>
    extends _$PredictionFailureCopyWithImpl<$Res, _$PredictionResponseFailure>
    implements _$$PredictionResponseFailureCopyWith<$Res> {
  __$$PredictionResponseFailureCopyWithImpl(_$PredictionResponseFailure _value,
      $Res Function(_$PredictionResponseFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PredictionResponseFailure implements PredictionResponseFailure {
  const _$PredictionResponseFailure();

  @override
  String toString() {
    return 'PredictionFailure.response()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PredictionResponseFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return response();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return response?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) {
    return response(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) {
    return response?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (response != null) {
      return response(this);
    }
    return orElse();
  }
}

abstract class PredictionResponseFailure implements PredictionFailure {
  const factory PredictionResponseFailure() = _$PredictionResponseFailure;
}

/// @nodoc
abstract class _$$PredictionCancelFailureCopyWith<$Res> {
  factory _$$PredictionCancelFailureCopyWith(_$PredictionCancelFailure value,
          $Res Function(_$PredictionCancelFailure) then) =
      __$$PredictionCancelFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PredictionCancelFailureCopyWithImpl<$Res>
    extends _$PredictionFailureCopyWithImpl<$Res, _$PredictionCancelFailure>
    implements _$$PredictionCancelFailureCopyWith<$Res> {
  __$$PredictionCancelFailureCopyWithImpl(_$PredictionCancelFailure _value,
      $Res Function(_$PredictionCancelFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PredictionCancelFailure implements PredictionCancelFailure {
  const _$PredictionCancelFailure();

  @override
  String toString() {
    return 'PredictionFailure.cancel()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PredictionCancelFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return cancel();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return cancel?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) {
    return cancel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) {
    return cancel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel(this);
    }
    return orElse();
  }
}

abstract class PredictionCancelFailure implements PredictionFailure {
  const factory PredictionCancelFailure() = _$PredictionCancelFailure;
}

/// @nodoc
abstract class _$$PredictionCacheFailureCopyWith<$Res> {
  factory _$$PredictionCacheFailureCopyWith(_$PredictionCacheFailure value,
          $Res Function(_$PredictionCacheFailure) then) =
      __$$PredictionCacheFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PredictionCacheFailureCopyWithImpl<$Res>
    extends _$PredictionFailureCopyWithImpl<$Res, _$PredictionCacheFailure>
    implements _$$PredictionCacheFailureCopyWith<$Res> {
  __$$PredictionCacheFailureCopyWithImpl(_$PredictionCacheFailure _value,
      $Res Function(_$PredictionCacheFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PredictionCacheFailure implements PredictionCacheFailure {
  const _$PredictionCacheFailure();

  @override
  String toString() {
    return 'PredictionFailure.cache()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PredictionCacheFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return cache();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return cache?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) {
    return cache(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) {
    return cache?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (cache != null) {
      return cache(this);
    }
    return orElse();
  }
}

abstract class PredictionCacheFailure implements PredictionFailure {
  const factory PredictionCacheFailure() = _$PredictionCacheFailure;
}

/// @nodoc
abstract class _$$PredictionUnknownFailureCopyWith<$Res> {
  factory _$$PredictionUnknownFailureCopyWith(_$PredictionUnknownFailure value,
          $Res Function(_$PredictionUnknownFailure) then) =
      __$$PredictionUnknownFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PredictionUnknownFailureCopyWithImpl<$Res>
    extends _$PredictionFailureCopyWithImpl<$Res, _$PredictionUnknownFailure>
    implements _$$PredictionUnknownFailureCopyWith<$Res> {
  __$$PredictionUnknownFailureCopyWithImpl(_$PredictionUnknownFailure _value,
      $Res Function(_$PredictionUnknownFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PredictionUnknownFailure implements PredictionUnknownFailure {
  const _$PredictionUnknownFailure();

  @override
  String toString() {
    return 'PredictionFailure.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PredictionUnknownFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class PredictionUnknownFailure implements PredictionFailure {
  const factory PredictionUnknownFailure() = _$PredictionUnknownFailure;
}

/// @nodoc
abstract class _$$PredictionAlreadyExistsFailureCopyWith<$Res> {
  factory _$$PredictionAlreadyExistsFailureCopyWith(
          _$PredictionAlreadyExistsFailure value,
          $Res Function(_$PredictionAlreadyExistsFailure) then) =
      __$$PredictionAlreadyExistsFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PredictionAlreadyExistsFailureCopyWithImpl<$Res>
    extends _$PredictionFailureCopyWithImpl<$Res,
        _$PredictionAlreadyExistsFailure>
    implements _$$PredictionAlreadyExistsFailureCopyWith<$Res> {
  __$$PredictionAlreadyExistsFailureCopyWithImpl(
      _$PredictionAlreadyExistsFailure _value,
      $Res Function(_$PredictionAlreadyExistsFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PredictionAlreadyExistsFailure
    implements PredictionAlreadyExistsFailure {
  const _$PredictionAlreadyExistsFailure();

  @override
  String toString() {
    return 'PredictionFailure.alreadyExists()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PredictionAlreadyExistsFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return alreadyExists();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return alreadyExists?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (alreadyExists != null) {
      return alreadyExists();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) {
    return alreadyExists(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) {
    return alreadyExists?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (alreadyExists != null) {
      return alreadyExists(this);
    }
    return orElse();
  }
}

abstract class PredictionAlreadyExistsFailure implements PredictionFailure {
  const factory PredictionAlreadyExistsFailure() =
      _$PredictionAlreadyExistsFailure;
}

/// @nodoc
abstract class _$$PredictionDoesNotExistFailureCopyWith<$Res> {
  factory _$$PredictionDoesNotExistFailureCopyWith(
          _$PredictionDoesNotExistFailure value,
          $Res Function(_$PredictionDoesNotExistFailure) then) =
      __$$PredictionDoesNotExistFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PredictionDoesNotExistFailureCopyWithImpl<$Res>
    extends _$PredictionFailureCopyWithImpl<$Res,
        _$PredictionDoesNotExistFailure>
    implements _$$PredictionDoesNotExistFailureCopyWith<$Res> {
  __$$PredictionDoesNotExistFailureCopyWithImpl(
      _$PredictionDoesNotExistFailure _value,
      $Res Function(_$PredictionDoesNotExistFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PredictionDoesNotExistFailure implements PredictionDoesNotExistFailure {
  const _$PredictionDoesNotExistFailure();

  @override
  String toString() {
    return 'PredictionFailure.doesNotExist()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PredictionDoesNotExistFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notFound,
    required TResult Function() timeout,
    required TResult Function() serialization,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() response,
    required TResult Function() cancel,
    required TResult Function() cache,
    required TResult Function() unknown,
    required TResult Function() alreadyExists,
    required TResult Function() doesNotExist,
  }) {
    return doesNotExist();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? notFound,
    TResult? Function()? timeout,
    TResult? Function()? serialization,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? response,
    TResult? Function()? cancel,
    TResult? Function()? cache,
    TResult? Function()? unknown,
    TResult? Function()? alreadyExists,
    TResult? Function()? doesNotExist,
  }) {
    return doesNotExist?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notFound,
    TResult Function()? timeout,
    TResult Function()? serialization,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? response,
    TResult Function()? cancel,
    TResult Function()? cache,
    TResult Function()? unknown,
    TResult Function()? alreadyExists,
    TResult Function()? doesNotExist,
    required TResult orElse(),
  }) {
    if (doesNotExist != null) {
      return doesNotExist();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PredictionNotFoundFailure value) notFound,
    required TResult Function(PredictionTimeoutFailure value) timeout,
    required TResult Function(PredictionSerializationFailure value)
        serialization,
    required TResult Function(PredictionSendTimeoutFailure value) sendTimeout,
    required TResult Function(PredictionReceiveTimeoutFailure value)
        receiveTimeout,
    required TResult Function(PredictionResponseFailure value) response,
    required TResult Function(PredictionCancelFailure value) cancel,
    required TResult Function(PredictionCacheFailure value) cache,
    required TResult Function(PredictionUnknownFailure value) unknown,
    required TResult Function(PredictionAlreadyExistsFailure value)
        alreadyExists,
    required TResult Function(PredictionDoesNotExistFailure value) doesNotExist,
  }) {
    return doesNotExist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PredictionNotFoundFailure value)? notFound,
    TResult? Function(PredictionTimeoutFailure value)? timeout,
    TResult? Function(PredictionSerializationFailure value)? serialization,
    TResult? Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult? Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult? Function(PredictionResponseFailure value)? response,
    TResult? Function(PredictionCancelFailure value)? cancel,
    TResult? Function(PredictionCacheFailure value)? cache,
    TResult? Function(PredictionUnknownFailure value)? unknown,
    TResult? Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult? Function(PredictionDoesNotExistFailure value)? doesNotExist,
  }) {
    return doesNotExist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PredictionNotFoundFailure value)? notFound,
    TResult Function(PredictionTimeoutFailure value)? timeout,
    TResult Function(PredictionSerializationFailure value)? serialization,
    TResult Function(PredictionSendTimeoutFailure value)? sendTimeout,
    TResult Function(PredictionReceiveTimeoutFailure value)? receiveTimeout,
    TResult Function(PredictionResponseFailure value)? response,
    TResult Function(PredictionCancelFailure value)? cancel,
    TResult Function(PredictionCacheFailure value)? cache,
    TResult Function(PredictionUnknownFailure value)? unknown,
    TResult Function(PredictionAlreadyExistsFailure value)? alreadyExists,
    TResult Function(PredictionDoesNotExistFailure value)? doesNotExist,
    required TResult orElse(),
  }) {
    if (doesNotExist != null) {
      return doesNotExist(this);
    }
    return orElse();
  }
}

abstract class PredictionDoesNotExistFailure implements PredictionFailure {
  const factory PredictionDoesNotExistFailure() =
      _$PredictionDoesNotExistFailure;
}
